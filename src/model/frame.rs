// This file is auto-generated by `gen/scripts/regen`. Do not edit.

#![allow(unused_parens)]
#![allow(unused_variables)]
#![allow(dead_code)]

use arrow2::{
	array::{ListArray, MutablePrimitiveArray, PrimitiveArray, StructArray},
	buffer::Buffer,
	datatypes::{DataType, Field},
	offset::{Offsets, OffsetsBuffer},
};
use byteorder::{ReadBytesExt, WriteBytesExt};
use std::io::{Result, Write};

use crate::{
	model::{
		columnar,
		game::{Port, NUM_PORTS},
		slippi::Version,
	},
	serde::de::Event,
};

type BE = byteorder::BigEndian;

/// Frame indexes start at -123, and reach 0 at "Go!".
pub const FIRST_INDEX: i32 = -123;

#[derive(Clone, Copy, Debug)]
pub struct PortOccupancy {
	pub port: Port,
	pub follower: bool,
}

pub struct Data {
	pub pre: Pre,
	pub post: Post,
}

impl Data {
	pub fn data_type(version: Version) -> DataType {
		DataType::Struct(vec![
			Field::new("pre", Pre::data_type(version).clone(), false),
			Field::new("post", Post::data_type(version).clone(), false),
		])
	}

	pub fn into_struct_array(self, version: Version) -> StructArray {
		let values = vec![
			self.pre.into_struct_array(version).boxed(),
			self.post.into_struct_array(version).boxed(),
		];
		StructArray::new(Self::data_type(version), values, None)
	}

	pub fn from_struct_array(array: StructArray, version: Version) -> Self {
		let (_, values, _) = array.into_data();
		Self {
			pre: Pre::from_struct_array(
				values[0]
					.as_any()
					.downcast_ref::<StructArray>()
					.unwrap()
					.clone(),
				version,
			),
			post: Post::from_struct_array(
				values[1]
					.as_any()
					.downcast_ref::<StructArray>()
					.unwrap()
					.clone(),
				version,
			),
		}
	}

	pub fn write_pre<W: Write>(
		&self,
		w: &mut W,
		version: Version,
		idx: usize,
		frame_id: i32,
		port: PortOccupancy,
	) -> Result<()> {
		w.write_u8(Event::FramePre as u8)?;
		w.write_i32::<BE>(frame_id)?;
		w.write_u8(port.port as u8)?;
		w.write_u8(match port.follower {
			true => 1,
			_ => 0,
		})?;
		self.pre.write(w, version, idx)?;
		Ok(())
	}

	pub fn write_post<W: Write>(
		&self,
		w: &mut W,
		version: Version,
		idx: usize,
		frame_id: i32,
		port: PortOccupancy,
	) -> Result<()> {
		w.write_u8(Event::FramePost as u8)?;
		w.write_i32::<BE>(frame_id)?;
		w.write_u8(port.port as u8)?;
		w.write_u8(match port.follower {
			true => 1,
			_ => 0,
		})?;
		self.post.write(w, version, idx)?;
		Ok(())
	}
}

pub struct MutableData {
	pub pre: MutablePre,
	pub post: MutablePost,
}

impl MutableData {
	pub fn with_capacity(capacity: usize, version: Version) -> Self {
		Self {
			pre: MutablePre::with_capacity(capacity, version),
			post: MutablePost::with_capacity(capacity, version),
		}
	}

	pub fn push_none(&mut self, version: Version) {
		self.pre.push_none(version);
		self.post.push_none(version);
	}
}

impl From<MutableData> for Data {
	fn from(d: MutableData) -> Self {
		Self {
			pre: d.pre.into(),
			post: d.post.into(),
		}
	}
}

pub struct PortData {
	pub port: Port,
	pub leader: Data,
	pub follower: Option<Data>,
}

impl PortData {
	pub fn data_type(version: Version, port: PortOccupancy) -> DataType {
		let mut fields = vec![Field::new(
			"leader",
			Data::data_type(version).clone(),
			false,
		)];
		if port.follower {
			fields.push(Field::new(
				"follower",
				Data::data_type(version).clone(),
				false,
			));
		}
		DataType::Struct(fields)
	}

	pub fn into_struct_array(self, version: Version, port: PortOccupancy) -> StructArray {
		let mut values = vec![self.leader.into_struct_array(version).boxed()];
		if let Some(follower) = self.follower {
			values.push(follower.into_struct_array(version).boxed());
		}
		StructArray::new(Self::data_type(version, port), values, None)
	}

	pub fn from_struct_array(array: StructArray, version: Version, port: Port) -> Self {
		let (_, values, _) = array.into_data();
		Self {
			port: port,
			leader: Data::from_struct_array(
				values[0]
					.as_any()
					.downcast_ref::<StructArray>()
					.unwrap()
					.clone(),
				version,
			),
			follower: values.get(1).map(|x| {
				Data::from_struct_array(
					x.as_any().downcast_ref::<StructArray>().unwrap().clone(),
					version,
				)
			}),
		}
	}

	pub fn write_pre<W: Write>(
		&self,
		w: &mut W,
		version: Version,
		idx: usize,
		frame_id: i32,
	) -> Result<()> {
		self.leader.write_pre(
			w,
			version,
			idx,
			frame_id,
			PortOccupancy {
				port: self.port,
				follower: false,
			},
		)?;
		self.follower
			.as_ref()
			.map(|f| {
				if f.pre
					.random_seed
					.validity()
					.map(|v| v.get_bit(idx))
					.unwrap_or(true)
				{
					f.write_pre(
						w,
						version,
						idx,
						frame_id,
						PortOccupancy {
							port: self.port,
							follower: true,
						},
					)
				} else {
					Ok(())
				}
			})
			.unwrap_or(Ok(()))
	}

	pub fn write_post<W: Write>(
		&self,
		w: &mut W,
		version: Version,
		idx: usize,
		frame_id: i32,
	) -> Result<()> {
		self.leader.write_post(
			w,
			version,
			idx,
			frame_id,
			PortOccupancy {
				port: self.port,
				follower: false,
			},
		)?;
		self.follower
			.as_ref()
			.map(|f| {
				if f.pre
					.random_seed
					.validity()
					.map(|v| v.get_bit(idx))
					.unwrap_or(true)
				{
					f.write_post(
						w,
						version,
						idx,
						frame_id,
						PortOccupancy {
							port: self.port,
							follower: true,
						},
					)
				} else {
					Ok(())
				}
			})
			.unwrap_or(Ok(()))
	}
}

pub struct MutablePortData {
	pub port: Port,
	pub leader: MutableData,
	pub follower: Option<MutableData>,
}

impl MutablePortData {
	pub fn with_capacity(capacity: usize, version: Version, port: PortOccupancy) -> Self {
		Self {
			port: port.port,
			leader: MutableData::with_capacity(capacity, version),
			follower: match port.follower {
				true => Some(MutableData::with_capacity(capacity, version)),
				_ => None,
			},
		}
	}
}

impl From<MutablePortData> for PortData {
	fn from(p: MutablePortData) -> Self {
		Self {
			port: p.port,
			leader: p.leader.into(),
			follower: p.follower.map(|f| f.into()),
		}
	}
}

pub struct Frame {
	pub id: PrimitiveArray<i32>,
	pub start: Start,
	pub end: End,
	pub port: Vec<PortData>,
	pub item_offset: OffsetsBuffer<i32>,
	pub item: Item,
}

impl Frame {
	pub fn port_data_type(version: Version, ports: &[PortOccupancy]) -> DataType {
		DataType::Struct(
			ports
				.iter()
				.enumerate()
				.map(|(i, p)| {
					Field::new(
						format!("{}", i),
						PortData::data_type(version, *p).clone(),
						false,
					)
				})
				.collect(),
		)
	}

	pub fn port_data_from_struct_array(array: StructArray, version: Version) -> Vec<PortData> {
		let (_, values, _) = array.into_data();
		let mut ports = vec![];
		for i in 0..NUM_PORTS {
			if let Some(a) = values.get(i as usize) {
				ports.push(PortData::from_struct_array(
					a.as_any().downcast_ref::<StructArray>().unwrap().clone(),
					version,
					Port::try_from(i).unwrap(),
				));
			}
		}
		ports
	}

	pub fn item_data_type(version: Version) -> DataType {
		DataType::List(Box::new(Field::new(
			"item",
			Item::data_type(version),
			false,
		)))
	}

	pub fn data_type(version: Version, ports: &[PortOccupancy]) -> DataType {
		DataType::Struct(vec![
			Field::new("id", DataType::Int32, false),
			Field::new("start", Start::data_type(version).clone(), false),
			Field::new("end", End::data_type(version).clone(), false),
			Field::new("port", Self::port_data_type(version, ports).clone(), false),
			Field::new("item", Self::item_data_type(version).clone(), false),
		])
	}

	pub fn into_struct_array(self, version: Version, ports: &[PortOccupancy]) -> StructArray {
		let start = self.start.into_struct_array(version).boxed();
		let end = self.end.into_struct_array(version).boxed();

		let port = {
			let values: Vec<_> = std::iter::zip(ports, self.port)
				.map(|(occupancy, data)| data.into_struct_array(version, *occupancy).boxed())
				.collect();
			StructArray::new(Self::port_data_type(version, ports), values, None).boxed()
		};

		let item = {
			let values = self.item.into_struct_array(version).boxed();
			ListArray::new(
				Self::item_data_type(version),
				self.item_offset,
				values,
				None,
			)
			.boxed()
		};

		StructArray::new(
			Self::data_type(version, ports),
			vec![self.id.boxed(), start, end, port, item],
			None,
		)
	}

	pub fn from_struct_array(array: StructArray, version: Version) -> Self {
		let (_, values, _) = array.into_data();
		let item_arrays = values[4]
			.as_any()
			.downcast_ref::<ListArray<i32>>()
			.unwrap()
			.clone();
		let item = item_arrays.values();
		let item_offset = item_arrays.offsets();

		Self {
			id: values[0]
				.as_any()
				.downcast_ref::<PrimitiveArray<i32>>()
				.unwrap()
				.clone(),
			start: Start::from_struct_array(
				values[1]
					.as_any()
					.downcast_ref::<StructArray>()
					.unwrap()
					.clone(),
				version,
			),
			end: End::from_struct_array(
				values[2]
					.as_any()
					.downcast_ref::<StructArray>()
					.unwrap()
					.clone(),
				version,
			),
			port: Self::port_data_from_struct_array(
				values[3]
					.as_any()
					.downcast_ref::<StructArray>()
					.unwrap()
					.clone(),
				version,
			),
			item_offset: item_offset.clone(),
			item: Item::from_struct_array(
				item.as_any().downcast_ref::<StructArray>().unwrap().clone(),
				version,
			),
		}
	}

	pub fn write<W: Write>(&self, w: &mut W, version: Version) -> Result<()> {
		for (idx, &frame_id) in self.id.values().iter().enumerate() {
			if version.gte(2, 2) {
				w.write_u8(Event::FrameStart as u8)?;
				w.write_i32::<BE>(frame_id)?;
				self.start.write(w, version, idx)?;
			}
			for port in &self.port {
				port.write_pre(w, version, idx, frame_id)?;
			}
			if version.gte(3, 0) {
				for item_idx in self.item_offset[idx] as usize..self.item_offset[idx + 1] as usize {
					w.write_u8(Event::Item as u8)?;
					w.write_i32::<BE>(frame_id)?;
					self.item.write(w, version, item_idx)?;
				}
			}
			for port in &self.port {
				port.write_post(w, version, idx, frame_id)?;
			}
			if version.gte(3, 0) {
				w.write_u8(Event::FrameEnd as u8)?;
				w.write_i32::<BE>(frame_id)?;
				self.end.write(w, version, idx)?;
			}
		}
		Ok(())
	}

	pub fn transpose_one(&self, i: usize, version: Version) -> columnar::Frame {
		columnar::Frame {
			start: self.start.transpose_one(i, version),
			end: self.end.transpose_one(i, version),
		}
	}

	pub fn rollback_indexes_initial(&self) -> Vec<usize> {
		self.rollback_indexes(self.id.values().as_slice().iter().enumerate())
	}

	pub fn rollback_indexes_final(&self) -> Vec<usize> {
		let mut result =
			self.rollback_indexes(self.id.values().as_slice().iter().enumerate().rev());
		result.reverse();
		result
	}

	fn rollback_indexes<'a>(&self, ids: impl Iterator<Item = (usize, &'a i32)>) -> Vec<usize> {
		let mut result = vec![];
		let mut seen_ids = vec![false; self.id.len()];
		for (idx, id) in ids {
			let zero_based_id = usize::try_from(id - FIRST_INDEX).unwrap();
			if !seen_ids[zero_based_id] {
				seen_ids[zero_based_id] = true;
				result.push(idx);
			}
		}
		result
	}
}

pub struct MutableFrame {
	pub id: MutablePrimitiveArray<i32>,
	pub start: MutableStart,
	pub end: MutableEnd,
	pub port: Vec<MutablePortData>,
	pub item_offset: Offsets<i32>,
	pub item: MutableItem,
}

impl MutableFrame {
	pub fn with_capacity(capacity: usize, version: Version, ports: &[PortOccupancy]) -> Self {
		Self {
			id: MutablePrimitiveArray::<i32>::with_capacity(capacity),
			start: MutableStart::with_capacity(capacity, version),
			end: MutableEnd::with_capacity(capacity, version),
			port: ports
				.iter()
				.map(|p| MutablePortData::with_capacity(capacity, version, *p))
				.collect(),
			item_offset: Offsets::<i32>::with_capacity(capacity),
			item: MutableItem::with_capacity(0, version),
		}
	}
}

impl From<MutableFrame> for Frame {
	fn from(f: MutableFrame) -> Self {
		Self {
			id: f.id.into(),
			start: f.start.into(),
			end: f.end.into(),
			port: f.port.into_iter().map(|p| p.into()).collect(),
			item_offset: OffsetsBuffer::try_from(Buffer::from(f.item_offset.into_inner())).unwrap(),
			item: f.item.into(),
		}
	}
}

pub struct MutablePost {
	pub character: MutablePrimitiveArray<u8>,
	pub state: MutablePrimitiveArray<u16>,
	pub position: MutablePosition,
	pub direction: MutablePrimitiveArray<f32>,
	pub percent: MutablePrimitiveArray<f32>,
	pub shield: MutablePrimitiveArray<f32>,
	pub last_attack_landed: MutablePrimitiveArray<u8>,
	pub combo_count: MutablePrimitiveArray<u8>,
	pub last_hit_by: MutablePrimitiveArray<u8>,
	pub stocks: MutablePrimitiveArray<u8>,
	pub state_age: Option<MutablePrimitiveArray<f32>>,
	pub state_flags: Option<MutableStateFlags>,
	pub misc_as: Option<MutablePrimitiveArray<f32>>,
	pub airborne: Option<MutablePrimitiveArray<u8>>,
	pub ground: Option<MutablePrimitiveArray<u16>>,
	pub jumps: Option<MutablePrimitiveArray<u8>>,
	pub l_cancel: Option<MutablePrimitiveArray<u8>>,
	pub hurtbox_state: Option<MutablePrimitiveArray<u8>>,
	pub velocities: Option<MutableVelocities>,
	pub hitlag: Option<MutablePrimitiveArray<f32>>,
	pub animation_index: Option<MutablePrimitiveArray<u32>>,
}

impl MutablePost {
	fn with_capacity(capacity: usize, version: Version) -> Self {
		Self {
			character: MutablePrimitiveArray::<u8>::with_capacity(capacity),
			state: MutablePrimitiveArray::<u16>::with_capacity(capacity),
			position: MutablePosition::with_capacity(capacity, version),
			direction: MutablePrimitiveArray::<f32>::with_capacity(capacity),
			percent: MutablePrimitiveArray::<f32>::with_capacity(capacity),
			shield: MutablePrimitiveArray::<f32>::with_capacity(capacity),
			last_attack_landed: MutablePrimitiveArray::<u8>::with_capacity(capacity),
			combo_count: MutablePrimitiveArray::<u8>::with_capacity(capacity),
			last_hit_by: MutablePrimitiveArray::<u8>::with_capacity(capacity),
			stocks: MutablePrimitiveArray::<u8>::with_capacity(capacity),
			state_age: version
				.gte(0, 2)
				.then(|| MutablePrimitiveArray::<f32>::with_capacity(capacity)),
			state_flags: version
				.gte(2, 0)
				.then(|| MutableStateFlags::with_capacity(capacity, version)),
			misc_as: version
				.gte(2, 0)
				.then(|| MutablePrimitiveArray::<f32>::with_capacity(capacity)),
			airborne: version
				.gte(2, 0)
				.then(|| MutablePrimitiveArray::<u8>::with_capacity(capacity)),
			ground: version
				.gte(2, 0)
				.then(|| MutablePrimitiveArray::<u16>::with_capacity(capacity)),
			jumps: version
				.gte(2, 0)
				.then(|| MutablePrimitiveArray::<u8>::with_capacity(capacity)),
			l_cancel: version
				.gte(2, 0)
				.then(|| MutablePrimitiveArray::<u8>::with_capacity(capacity)),
			hurtbox_state: version
				.gte(2, 1)
				.then(|| MutablePrimitiveArray::<u8>::with_capacity(capacity)),
			velocities: version
				.gte(3, 5)
				.then(|| MutableVelocities::with_capacity(capacity, version)),
			hitlag: version
				.gte(3, 8)
				.then(|| MutablePrimitiveArray::<f32>::with_capacity(capacity)),
			animation_index: version
				.gte(3, 11)
				.then(|| MutablePrimitiveArray::<u32>::with_capacity(capacity)),
		}
	}

	pub fn push_none(&mut self, version: Version) {
		self.character.push(None);
		self.state.push(None);
		self.position.push_none(version);
		self.direction.push(None);
		self.percent.push(None);
		self.shield.push(None);
		self.last_attack_landed.push(None);
		self.combo_count.push(None);
		self.last_hit_by.push(None);
		self.stocks.push(None);
		if version.gte(0, 2) {
			self.state_age.as_mut().unwrap().push(None);
			if version.gte(2, 0) {
				self.state_flags.as_mut().unwrap().push_none(version);
				self.misc_as.as_mut().unwrap().push(None);
				self.airborne.as_mut().unwrap().push(None);
				self.ground.as_mut().unwrap().push(None);
				self.jumps.as_mut().unwrap().push(None);
				self.l_cancel.as_mut().unwrap().push(None);
				if version.gte(2, 1) {
					self.hurtbox_state.as_mut().unwrap().push(None);
					if version.gte(3, 5) {
						self.velocities.as_mut().unwrap().push_none(version);
						if version.gte(3, 8) {
							self.hitlag.as_mut().unwrap().push(None);
							if version.gte(3, 11) {
								self.animation_index.as_mut().unwrap().push(None)
							}
						}
					}
				}
			}
		}
	}

	pub fn read_push(&mut self, r: &mut &[u8], version: Version) -> Result<()> {
		r.read_u8().map(|x| self.character.push(Some(x)))?;
		r.read_u16::<BE>().map(|x| self.state.push(Some(x)))?;
		self.position.read_push(r, version)?;
		r.read_f32::<BE>().map(|x| self.direction.push(Some(x)))?;
		r.read_f32::<BE>().map(|x| self.percent.push(Some(x)))?;
		r.read_f32::<BE>().map(|x| self.shield.push(Some(x)))?;
		r.read_u8().map(|x| self.last_attack_landed.push(Some(x)))?;
		r.read_u8().map(|x| self.combo_count.push(Some(x)))?;
		r.read_u8().map(|x| self.last_hit_by.push(Some(x)))?;
		r.read_u8().map(|x| self.stocks.push(Some(x)))?;
		if version.gte(0, 2) {
			r.read_f32::<BE>()
				.map(|x| self.state_age.as_mut().unwrap().push(Some(x)))?;
			if version.gte(2, 0) {
				self.state_flags.as_mut().unwrap().read_push(r, version)?;
				r.read_f32::<BE>()
					.map(|x| self.misc_as.as_mut().unwrap().push(Some(x)))?;
				r.read_u8()
					.map(|x| self.airborne.as_mut().unwrap().push(Some(x)))?;
				r.read_u16::<BE>()
					.map(|x| self.ground.as_mut().unwrap().push(Some(x)))?;
				r.read_u8()
					.map(|x| self.jumps.as_mut().unwrap().push(Some(x)))?;
				r.read_u8()
					.map(|x| self.l_cancel.as_mut().unwrap().push(Some(x)))?;
				if version.gte(2, 1) {
					r.read_u8()
						.map(|x| self.hurtbox_state.as_mut().unwrap().push(Some(x)))?;
					if version.gte(3, 5) {
						self.velocities.as_mut().unwrap().read_push(r, version)?;
						if version.gte(3, 8) {
							r.read_f32::<BE>()
								.map(|x| self.hitlag.as_mut().unwrap().push(Some(x)))?;
							if version.gte(3, 11) {
								r.read_u32::<BE>()
									.map(|x| self.animation_index.as_mut().unwrap().push(Some(x)))?
							}
						}
					}
				}
			}
		};
		Ok(())
	}
}

pub struct MutableStart {
	pub random_seed: Option<MutablePrimitiveArray<u32>>,
	pub scene_frame_counter: Option<MutablePrimitiveArray<u32>>,
}

impl MutableStart {
	fn with_capacity(capacity: usize, version: Version) -> Self {
		Self {
			random_seed: version
				.gte(2, 2)
				.then(|| MutablePrimitiveArray::<u32>::with_capacity(capacity)),
			scene_frame_counter: version
				.gte(3, 10)
				.then(|| MutablePrimitiveArray::<u32>::with_capacity(capacity)),
		}
	}

	pub fn push_none(&mut self, version: Version) {
		if version.gte(2, 2) {
			self.random_seed.as_mut().unwrap().push(None);
			if version.gte(3, 10) {
				self.scene_frame_counter.as_mut().unwrap().push(None)
			}
		}
	}

	pub fn read_push(&mut self, r: &mut &[u8], version: Version) -> Result<()> {
		if version.gte(2, 2) {
			r.read_u32::<BE>()
				.map(|x| self.random_seed.as_mut().unwrap().push(Some(x)))?;
			if version.gte(3, 10) {
				r.read_u32::<BE>()
					.map(|x| self.scene_frame_counter.as_mut().unwrap().push(Some(x)))?
			}
		};
		Ok(())
	}
}

pub struct MutableEnd {
	pub latest_finalized_frame: Option<MutablePrimitiveArray<i32>>,
}

impl MutableEnd {
	fn with_capacity(capacity: usize, version: Version) -> Self {
		Self {
			latest_finalized_frame: version
				.gte(3, 7)
				.then(|| MutablePrimitiveArray::<i32>::with_capacity(capacity)),
		}
	}

	pub fn push_none(&mut self, version: Version) {
		if version.gte(3, 7) {
			self.latest_finalized_frame.as_mut().unwrap().push(None)
		}
	}

	pub fn read_push(&mut self, r: &mut &[u8], version: Version) -> Result<()> {
		if version.gte(3, 7) {
			r.read_i32::<BE>()
				.map(|x| self.latest_finalized_frame.as_mut().unwrap().push(Some(x)))?
		};
		Ok(())
	}
}

pub struct MutableStateFlags(
	pub MutablePrimitiveArray<u8>,
	pub MutablePrimitiveArray<u8>,
	pub MutablePrimitiveArray<u8>,
	pub MutablePrimitiveArray<u8>,
	pub MutablePrimitiveArray<u8>,
);

impl MutableStateFlags {
	fn with_capacity(capacity: usize, version: Version) -> Self {
		Self(
			MutablePrimitiveArray::<u8>::with_capacity(capacity),
			MutablePrimitiveArray::<u8>::with_capacity(capacity),
			MutablePrimitiveArray::<u8>::with_capacity(capacity),
			MutablePrimitiveArray::<u8>::with_capacity(capacity),
			MutablePrimitiveArray::<u8>::with_capacity(capacity),
		)
	}

	pub fn push_none(&mut self, version: Version) {
		self.0.push(None);
		self.1.push(None);
		self.2.push(None);
		self.3.push(None);
		self.4.push(None)
	}

	pub fn read_push(&mut self, r: &mut &[u8], version: Version) -> Result<()> {
		r.read_u8().map(|x| self.0.push(Some(x)))?;
		r.read_u8().map(|x| self.1.push(Some(x)))?;
		r.read_u8().map(|x| self.2.push(Some(x)))?;
		r.read_u8().map(|x| self.3.push(Some(x)))?;
		r.read_u8().map(|x| self.4.push(Some(x)))?;
		Ok(())
	}
}

pub struct MutablePre {
	pub random_seed: MutablePrimitiveArray<u32>,
	pub state: MutablePrimitiveArray<u16>,
	pub position: MutablePosition,
	pub direction: MutablePrimitiveArray<f32>,
	pub joystick: MutablePosition,
	pub cstick: MutablePosition,
	pub triggers: MutablePrimitiveArray<f32>,
	pub buttons: MutablePrimitiveArray<u32>,
	pub buttons_physical: MutablePrimitiveArray<u16>,
	pub triggers_physical: MutableTriggersPhysical,
	pub raw_analog_x: Option<MutablePrimitiveArray<i8>>,
	pub percent: Option<MutablePrimitiveArray<f32>>,
}

impl MutablePre {
	fn with_capacity(capacity: usize, version: Version) -> Self {
		Self {
			random_seed: MutablePrimitiveArray::<u32>::with_capacity(capacity),
			state: MutablePrimitiveArray::<u16>::with_capacity(capacity),
			position: MutablePosition::with_capacity(capacity, version),
			direction: MutablePrimitiveArray::<f32>::with_capacity(capacity),
			joystick: MutablePosition::with_capacity(capacity, version),
			cstick: MutablePosition::with_capacity(capacity, version),
			triggers: MutablePrimitiveArray::<f32>::with_capacity(capacity),
			buttons: MutablePrimitiveArray::<u32>::with_capacity(capacity),
			buttons_physical: MutablePrimitiveArray::<u16>::with_capacity(capacity),
			triggers_physical: MutableTriggersPhysical::with_capacity(capacity, version),
			raw_analog_x: version
				.gte(1, 2)
				.then(|| MutablePrimitiveArray::<i8>::with_capacity(capacity)),
			percent: version
				.gte(1, 4)
				.then(|| MutablePrimitiveArray::<f32>::with_capacity(capacity)),
		}
	}

	pub fn push_none(&mut self, version: Version) {
		self.random_seed.push(None);
		self.state.push(None);
		self.position.push_none(version);
		self.direction.push(None);
		self.joystick.push_none(version);
		self.cstick.push_none(version);
		self.triggers.push(None);
		self.buttons.push(None);
		self.buttons_physical.push(None);
		self.triggers_physical.push_none(version);
		if version.gte(1, 2) {
			self.raw_analog_x.as_mut().unwrap().push(None);
			if version.gte(1, 4) {
				self.percent.as_mut().unwrap().push(None)
			}
		}
	}

	pub fn read_push(&mut self, r: &mut &[u8], version: Version) -> Result<()> {
		r.read_u32::<BE>().map(|x| self.random_seed.push(Some(x)))?;
		r.read_u16::<BE>().map(|x| self.state.push(Some(x)))?;
		self.position.read_push(r, version)?;
		r.read_f32::<BE>().map(|x| self.direction.push(Some(x)))?;
		self.joystick.read_push(r, version)?;
		self.cstick.read_push(r, version)?;
		r.read_f32::<BE>().map(|x| self.triggers.push(Some(x)))?;
		r.read_u32::<BE>().map(|x| self.buttons.push(Some(x)))?;
		r.read_u16::<BE>()
			.map(|x| self.buttons_physical.push(Some(x)))?;
		self.triggers_physical.read_push(r, version)?;
		if version.gte(1, 2) {
			r.read_i8()
				.map(|x| self.raw_analog_x.as_mut().unwrap().push(Some(x)))?;
			if version.gte(1, 4) {
				r.read_f32::<BE>()
					.map(|x| self.percent.as_mut().unwrap().push(Some(x)))?
			}
		};
		Ok(())
	}
}

pub struct MutableItemMisc(
	pub MutablePrimitiveArray<u8>,
	pub MutablePrimitiveArray<u8>,
	pub MutablePrimitiveArray<u8>,
	pub MutablePrimitiveArray<u8>,
);

impl MutableItemMisc {
	fn with_capacity(capacity: usize, version: Version) -> Self {
		Self(
			MutablePrimitiveArray::<u8>::with_capacity(capacity),
			MutablePrimitiveArray::<u8>::with_capacity(capacity),
			MutablePrimitiveArray::<u8>::with_capacity(capacity),
			MutablePrimitiveArray::<u8>::with_capacity(capacity),
		)
	}

	pub fn push_none(&mut self, version: Version) {
		self.0.push(None);
		self.1.push(None);
		self.2.push(None);
		self.3.push(None)
	}

	pub fn read_push(&mut self, r: &mut &[u8], version: Version) -> Result<()> {
		r.read_u8().map(|x| self.0.push(Some(x)))?;
		r.read_u8().map(|x| self.1.push(Some(x)))?;
		r.read_u8().map(|x| self.2.push(Some(x)))?;
		r.read_u8().map(|x| self.3.push(Some(x)))?;
		Ok(())
	}
}

pub struct MutablePosition {
	pub x: MutablePrimitiveArray<f32>,
	pub y: MutablePrimitiveArray<f32>,
}

impl MutablePosition {
	fn with_capacity(capacity: usize, version: Version) -> Self {
		Self {
			x: MutablePrimitiveArray::<f32>::with_capacity(capacity),
			y: MutablePrimitiveArray::<f32>::with_capacity(capacity),
		}
	}

	pub fn push_none(&mut self, version: Version) {
		self.x.push(None);
		self.y.push(None)
	}

	pub fn read_push(&mut self, r: &mut &[u8], version: Version) -> Result<()> {
		r.read_f32::<BE>().map(|x| self.x.push(Some(x)))?;
		r.read_f32::<BE>().map(|x| self.y.push(Some(x)))?;
		Ok(())
	}
}

pub struct MutableVelocities {
	pub self_x_air: MutablePrimitiveArray<f32>,
	pub self_y: MutablePrimitiveArray<f32>,
	pub knockback_x: MutablePrimitiveArray<f32>,
	pub knockback_y: MutablePrimitiveArray<f32>,
	pub self_x_ground: MutablePrimitiveArray<f32>,
}

impl MutableVelocities {
	fn with_capacity(capacity: usize, version: Version) -> Self {
		Self {
			self_x_air: MutablePrimitiveArray::<f32>::with_capacity(capacity),
			self_y: MutablePrimitiveArray::<f32>::with_capacity(capacity),
			knockback_x: MutablePrimitiveArray::<f32>::with_capacity(capacity),
			knockback_y: MutablePrimitiveArray::<f32>::with_capacity(capacity),
			self_x_ground: MutablePrimitiveArray::<f32>::with_capacity(capacity),
		}
	}

	pub fn push_none(&mut self, version: Version) {
		self.self_x_air.push(None);
		self.self_y.push(None);
		self.knockback_x.push(None);
		self.knockback_y.push(None);
		self.self_x_ground.push(None)
	}

	pub fn read_push(&mut self, r: &mut &[u8], version: Version) -> Result<()> {
		r.read_f32::<BE>().map(|x| self.self_x_air.push(Some(x)))?;
		r.read_f32::<BE>().map(|x| self.self_y.push(Some(x)))?;
		r.read_f32::<BE>().map(|x| self.knockback_x.push(Some(x)))?;
		r.read_f32::<BE>().map(|x| self.knockback_y.push(Some(x)))?;
		r.read_f32::<BE>()
			.map(|x| self.self_x_ground.push(Some(x)))?;
		Ok(())
	}
}

pub struct MutableTriggersPhysical {
	pub l: MutablePrimitiveArray<f32>,
	pub r: MutablePrimitiveArray<f32>,
}

impl MutableTriggersPhysical {
	fn with_capacity(capacity: usize, version: Version) -> Self {
		Self {
			l: MutablePrimitiveArray::<f32>::with_capacity(capacity),
			r: MutablePrimitiveArray::<f32>::with_capacity(capacity),
		}
	}

	pub fn push_none(&mut self, version: Version) {
		self.l.push(None);
		self.r.push(None)
	}

	pub fn read_push(&mut self, r: &mut &[u8], version: Version) -> Result<()> {
		r.read_f32::<BE>().map(|x| self.l.push(Some(x)))?;
		r.read_f32::<BE>().map(|x| self.r.push(Some(x)))?;
		Ok(())
	}
}

pub struct MutableVelocity {
	pub x: MutablePrimitiveArray<f32>,
	pub y: MutablePrimitiveArray<f32>,
}

impl MutableVelocity {
	fn with_capacity(capacity: usize, version: Version) -> Self {
		Self {
			x: MutablePrimitiveArray::<f32>::with_capacity(capacity),
			y: MutablePrimitiveArray::<f32>::with_capacity(capacity),
		}
	}

	pub fn push_none(&mut self, version: Version) {
		self.x.push(None);
		self.y.push(None)
	}

	pub fn read_push(&mut self, r: &mut &[u8], version: Version) -> Result<()> {
		r.read_f32::<BE>().map(|x| self.x.push(Some(x)))?;
		r.read_f32::<BE>().map(|x| self.y.push(Some(x)))?;
		Ok(())
	}
}

pub struct MutableItem {
	pub r#type: MutablePrimitiveArray<u16>,
	pub state: MutablePrimitiveArray<u8>,
	pub direction: MutablePrimitiveArray<f32>,
	pub velocity: MutableVelocity,
	pub position: MutablePosition,
	pub damage: MutablePrimitiveArray<u16>,
	pub timer: MutablePrimitiveArray<f32>,
	pub id: MutablePrimitiveArray<u32>,
	pub misc: Option<MutableItemMisc>,
	pub owner: Option<MutablePrimitiveArray<i8>>,
}

impl MutableItem {
	fn with_capacity(capacity: usize, version: Version) -> Self {
		Self {
			r#type: MutablePrimitiveArray::<u16>::with_capacity(capacity),
			state: MutablePrimitiveArray::<u8>::with_capacity(capacity),
			direction: MutablePrimitiveArray::<f32>::with_capacity(capacity),
			velocity: MutableVelocity::with_capacity(capacity, version),
			position: MutablePosition::with_capacity(capacity, version),
			damage: MutablePrimitiveArray::<u16>::with_capacity(capacity),
			timer: MutablePrimitiveArray::<f32>::with_capacity(capacity),
			id: MutablePrimitiveArray::<u32>::with_capacity(capacity),
			misc: version
				.gte(3, 2)
				.then(|| MutableItemMisc::with_capacity(capacity, version)),
			owner: version
				.gte(3, 6)
				.then(|| MutablePrimitiveArray::<i8>::with_capacity(capacity)),
		}
	}

	pub fn push_none(&mut self, version: Version) {
		self.r#type.push(None);
		self.state.push(None);
		self.direction.push(None);
		self.velocity.push_none(version);
		self.position.push_none(version);
		self.damage.push(None);
		self.timer.push(None);
		self.id.push(None);
		if version.gte(3, 2) {
			self.misc.as_mut().unwrap().push_none(version);
			if version.gte(3, 6) {
				self.owner.as_mut().unwrap().push(None)
			}
		}
	}

	pub fn read_push(&mut self, r: &mut &[u8], version: Version) -> Result<()> {
		r.read_u16::<BE>().map(|x| self.r#type.push(Some(x)))?;
		r.read_u8().map(|x| self.state.push(Some(x)))?;
		r.read_f32::<BE>().map(|x| self.direction.push(Some(x)))?;
		self.velocity.read_push(r, version)?;
		self.position.read_push(r, version)?;
		r.read_u16::<BE>().map(|x| self.damage.push(Some(x)))?;
		r.read_f32::<BE>().map(|x| self.timer.push(Some(x)))?;
		r.read_u32::<BE>().map(|x| self.id.push(Some(x)))?;
		if version.gte(3, 2) {
			self.misc.as_mut().unwrap().read_push(r, version)?;
			if version.gte(3, 6) {
				r.read_i8()
					.map(|x| self.owner.as_mut().unwrap().push(Some(x)))?
			}
		};
		Ok(())
	}
}

pub struct Post {
	pub character: PrimitiveArray<u8>,
	pub state: PrimitiveArray<u16>,
	pub position: Position,
	pub direction: PrimitiveArray<f32>,
	pub percent: PrimitiveArray<f32>,
	pub shield: PrimitiveArray<f32>,
	pub last_attack_landed: PrimitiveArray<u8>,
	pub combo_count: PrimitiveArray<u8>,
	pub last_hit_by: PrimitiveArray<u8>,
	pub stocks: PrimitiveArray<u8>,
	pub state_age: Option<PrimitiveArray<f32>>,
	pub state_flags: Option<StateFlags>,
	pub misc_as: Option<PrimitiveArray<f32>>,
	pub airborne: Option<PrimitiveArray<u8>>,
	pub ground: Option<PrimitiveArray<u16>>,
	pub jumps: Option<PrimitiveArray<u8>>,
	pub l_cancel: Option<PrimitiveArray<u8>>,
	pub hurtbox_state: Option<PrimitiveArray<u8>>,
	pub velocities: Option<Velocities>,
	pub hitlag: Option<PrimitiveArray<f32>>,
	pub animation_index: Option<PrimitiveArray<u32>>,
}

impl Post {
	fn data_type(version: Version) -> DataType {
		let mut fields = vec![];
		{
			fields.push(Field::new("character", DataType::UInt8, false));
			fields.push(Field::new("state", DataType::UInt16, false));
			fields.push(Field::new("position", Position::data_type(version), false));
			fields.push(Field::new("direction", DataType::Float32, false));
			fields.push(Field::new("percent", DataType::Float32, false));
			fields.push(Field::new("shield", DataType::Float32, false));
			fields.push(Field::new("last_attack_landed", DataType::UInt8, false));
			fields.push(Field::new("combo_count", DataType::UInt8, false));
			fields.push(Field::new("last_hit_by", DataType::UInt8, false));
			fields.push(Field::new("stocks", DataType::UInt8, false));
			if version.gte(0, 2) {
				fields.push(Field::new("state_age", DataType::Float32, false));
				if version.gte(2, 0) {
					fields.push(Field::new(
						"state_flags",
						StateFlags::data_type(version),
						false,
					));
					fields.push(Field::new("misc_as", DataType::Float32, false));
					fields.push(Field::new("airborne", DataType::UInt8, false));
					fields.push(Field::new("ground", DataType::UInt16, false));
					fields.push(Field::new("jumps", DataType::UInt8, false));
					fields.push(Field::new("l_cancel", DataType::UInt8, false));
					if version.gte(2, 1) {
						fields.push(Field::new("hurtbox_state", DataType::UInt8, false));
						if version.gte(3, 5) {
							fields.push(Field::new(
								"velocities",
								Velocities::data_type(version),
								false,
							));
							if version.gte(3, 8) {
								fields.push(Field::new("hitlag", DataType::Float32, false));
								if version.gte(3, 11) {
									fields.push(Field::new(
										"animation_index",
										DataType::UInt32,
										false,
									))
								}
							}
						}
					}
				}
			}
		};
		DataType::Struct(fields)
	}

	fn into_struct_array(self, version: Version) -> StructArray {
		let mut values = vec![];
		{
			values.push(self.character.boxed());
			values.push(self.state.boxed());
			values.push(self.position.into_struct_array(version).boxed());
			values.push(self.direction.boxed());
			values.push(self.percent.boxed());
			values.push(self.shield.boxed());
			values.push(self.last_attack_landed.boxed());
			values.push(self.combo_count.boxed());
			values.push(self.last_hit_by.boxed());
			values.push(self.stocks.boxed());
			if version.gte(0, 2) {
				values.push(self.state_age.unwrap().boxed());
				if version.gte(2, 0) {
					values.push(self.state_flags.unwrap().into_struct_array(version).boxed());
					values.push(self.misc_as.unwrap().boxed());
					values.push(self.airborne.unwrap().boxed());
					values.push(self.ground.unwrap().boxed());
					values.push(self.jumps.unwrap().boxed());
					values.push(self.l_cancel.unwrap().boxed());
					if version.gte(2, 1) {
						values.push(self.hurtbox_state.unwrap().boxed());
						if version.gte(3, 5) {
							values
								.push(self.velocities.unwrap().into_struct_array(version).boxed());
							if version.gte(3, 8) {
								values.push(self.hitlag.unwrap().boxed());
								if version.gte(3, 11) {
									values.push(self.animation_index.unwrap().boxed())
								}
							}
						}
					}
				}
			}
		};
		StructArray::new(Self::data_type(version), values, None)
	}

	fn from_struct_array(array: StructArray, version: Version) -> Self {
		let (_, values, _) = array.into_data();
		Self {
			character: values[0]
				.as_any()
				.downcast_ref::<PrimitiveArray<u8>>()
				.unwrap()
				.clone(),
			state: values[1]
				.as_any()
				.downcast_ref::<PrimitiveArray<u16>>()
				.unwrap()
				.clone(),
			position: Position::from_struct_array(
				values[2]
					.as_any()
					.downcast_ref::<StructArray>()
					.unwrap()
					.clone(),
				version,
			),
			direction: values[3]
				.as_any()
				.downcast_ref::<PrimitiveArray<f32>>()
				.unwrap()
				.clone(),
			percent: values[4]
				.as_any()
				.downcast_ref::<PrimitiveArray<f32>>()
				.unwrap()
				.clone(),
			shield: values[5]
				.as_any()
				.downcast_ref::<PrimitiveArray<f32>>()
				.unwrap()
				.clone(),
			last_attack_landed: values[6]
				.as_any()
				.downcast_ref::<PrimitiveArray<u8>>()
				.unwrap()
				.clone(),
			combo_count: values[7]
				.as_any()
				.downcast_ref::<PrimitiveArray<u8>>()
				.unwrap()
				.clone(),
			last_hit_by: values[8]
				.as_any()
				.downcast_ref::<PrimitiveArray<u8>>()
				.unwrap()
				.clone(),
			stocks: values[9]
				.as_any()
				.downcast_ref::<PrimitiveArray<u8>>()
				.unwrap()
				.clone(),
			state_age: values.get(10).map(|x| {
				x.as_any()
					.downcast_ref::<PrimitiveArray<f32>>()
					.unwrap()
					.clone()
			}),
			state_flags: values.get(11).map(|x| {
				StateFlags::from_struct_array(
					x.as_any().downcast_ref::<StructArray>().unwrap().clone(),
					version,
				)
			}),
			misc_as: values.get(12).map(|x| {
				x.as_any()
					.downcast_ref::<PrimitiveArray<f32>>()
					.unwrap()
					.clone()
			}),
			airborne: values.get(13).map(|x| {
				x.as_any()
					.downcast_ref::<PrimitiveArray<u8>>()
					.unwrap()
					.clone()
			}),
			ground: values.get(14).map(|x| {
				x.as_any()
					.downcast_ref::<PrimitiveArray<u16>>()
					.unwrap()
					.clone()
			}),
			jumps: values.get(15).map(|x| {
				x.as_any()
					.downcast_ref::<PrimitiveArray<u8>>()
					.unwrap()
					.clone()
			}),
			l_cancel: values.get(16).map(|x| {
				x.as_any()
					.downcast_ref::<PrimitiveArray<u8>>()
					.unwrap()
					.clone()
			}),
			hurtbox_state: values.get(17).map(|x| {
				x.as_any()
					.downcast_ref::<PrimitiveArray<u8>>()
					.unwrap()
					.clone()
			}),
			velocities: values.get(18).map(|x| {
				Velocities::from_struct_array(
					x.as_any().downcast_ref::<StructArray>().unwrap().clone(),
					version,
				)
			}),
			hitlag: values.get(19).map(|x| {
				x.as_any()
					.downcast_ref::<PrimitiveArray<f32>>()
					.unwrap()
					.clone()
			}),
			animation_index: values.get(20).map(|x| {
				x.as_any()
					.downcast_ref::<PrimitiveArray<u32>>()
					.unwrap()
					.clone()
			}),
		}
	}

	fn write<W: Write>(&self, w: &mut W, version: Version, i: usize) -> Result<()> {
		w.write_u8(self.character.value(i))?;
		w.write_u16::<BE>(self.state.value(i))?;
		self.position.write(w, version, i)?;
		w.write_f32::<BE>(self.direction.value(i))?;
		w.write_f32::<BE>(self.percent.value(i))?;
		w.write_f32::<BE>(self.shield.value(i))?;
		w.write_u8(self.last_attack_landed.value(i))?;
		w.write_u8(self.combo_count.value(i))?;
		w.write_u8(self.last_hit_by.value(i))?;
		w.write_u8(self.stocks.value(i))?;
		if version.gte(0, 2) {
			w.write_f32::<BE>(self.state_age.as_ref().unwrap().value(i))?;
			if version.gte(2, 0) {
				self.state_flags.as_ref().unwrap().write(w, version, i)?;
				w.write_f32::<BE>(self.misc_as.as_ref().unwrap().value(i))?;
				w.write_u8(self.airborne.as_ref().unwrap().value(i))?;
				w.write_u16::<BE>(self.ground.as_ref().unwrap().value(i))?;
				w.write_u8(self.jumps.as_ref().unwrap().value(i))?;
				w.write_u8(self.l_cancel.as_ref().unwrap().value(i))?;
				if version.gte(2, 1) {
					w.write_u8(self.hurtbox_state.as_ref().unwrap().value(i))?;
					if version.gte(3, 5) {
						self.velocities.as_ref().unwrap().write(w, version, i)?;
						if version.gte(3, 8) {
							w.write_f32::<BE>(self.hitlag.as_ref().unwrap().value(i))?;
							if version.gte(3, 11) {
								w.write_u32::<BE>(self.animation_index.as_ref().unwrap().value(i))?
							}
						}
					}
				}
			}
		};
		Ok(())
	}

	pub fn transpose_one(&self, i: usize, version: Version) -> columnar::Post {
		columnar::Post {
			character: self.character.values()[i],
			state: self.state.values()[i],
			position: self.position.transpose_one(i, version),
			direction: self.direction.values()[i],
			percent: self.percent.values()[i],
			shield: self.shield.values()[i],
			last_attack_landed: self.last_attack_landed.values()[i],
			combo_count: self.combo_count.values()[i],
			last_hit_by: self.last_hit_by.values()[i],
			stocks: self.stocks.values()[i],
			state_age: self.state_age.as_ref().map(|x| x.values()[i]),
			state_flags: self
				.state_flags
				.as_ref()
				.map(|x| x.transpose_one(i, version)),
			misc_as: self.misc_as.as_ref().map(|x| x.values()[i]),
			airborne: self.airborne.as_ref().map(|x| x.values()[i]),
			ground: self.ground.as_ref().map(|x| x.values()[i]),
			jumps: self.jumps.as_ref().map(|x| x.values()[i]),
			l_cancel: self.l_cancel.as_ref().map(|x| x.values()[i]),
			hurtbox_state: self.hurtbox_state.as_ref().map(|x| x.values()[i]),
			velocities: self
				.velocities
				.as_ref()
				.map(|x| x.transpose_one(i, version)),
			hitlag: self.hitlag.as_ref().map(|x| x.values()[i]),
			animation_index: self.animation_index.as_ref().map(|x| x.values()[i]),
		}
	}
}

impl From<MutablePost> for Post {
	fn from(x: MutablePost) -> Self {
		Self {
			character: x.character.into(),
			state: x.state.into(),
			position: x.position.into(),
			direction: x.direction.into(),
			percent: x.percent.into(),
			shield: x.shield.into(),
			last_attack_landed: x.last_attack_landed.into(),
			combo_count: x.combo_count.into(),
			last_hit_by: x.last_hit_by.into(),
			stocks: x.stocks.into(),
			state_age: x.state_age.map(|x| x.into()),
			state_flags: x.state_flags.map(|x| x.into()),
			misc_as: x.misc_as.map(|x| x.into()),
			airborne: x.airborne.map(|x| x.into()),
			ground: x.ground.map(|x| x.into()),
			jumps: x.jumps.map(|x| x.into()),
			l_cancel: x.l_cancel.map(|x| x.into()),
			hurtbox_state: x.hurtbox_state.map(|x| x.into()),
			velocities: x.velocities.map(|x| x.into()),
			hitlag: x.hitlag.map(|x| x.into()),
			animation_index: x.animation_index.map(|x| x.into()),
		}
	}
}

pub struct Start {
	pub random_seed: Option<PrimitiveArray<u32>>,
	pub scene_frame_counter: Option<PrimitiveArray<u32>>,
}

impl Start {
	fn data_type(version: Version) -> DataType {
		let mut fields = vec![];
		{
			if version.gte(2, 2) {
				fields.push(Field::new("random_seed", DataType::UInt32, false));
				if version.gte(3, 10) {
					fields.push(Field::new("scene_frame_counter", DataType::UInt32, false))
				}
			}
		};
		DataType::Struct(fields)
	}

	fn into_struct_array(self, version: Version) -> StructArray {
		let mut values = vec![];
		{
			if version.gte(2, 2) {
				values.push(self.random_seed.unwrap().boxed());
				if version.gte(3, 10) {
					values.push(self.scene_frame_counter.unwrap().boxed())
				}
			}
		};
		StructArray::new(Self::data_type(version), values, None)
	}

	fn from_struct_array(array: StructArray, version: Version) -> Self {
		let (_, values, _) = array.into_data();
		Self {
			random_seed: values.get(0).map(|x| {
				x.as_any()
					.downcast_ref::<PrimitiveArray<u32>>()
					.unwrap()
					.clone()
			}),
			scene_frame_counter: values.get(1).map(|x| {
				x.as_any()
					.downcast_ref::<PrimitiveArray<u32>>()
					.unwrap()
					.clone()
			}),
		}
	}

	fn write<W: Write>(&self, w: &mut W, version: Version, i: usize) -> Result<()> {
		if version.gte(2, 2) {
			w.write_u32::<BE>(self.random_seed.as_ref().unwrap().value(i))?;
			if version.gte(3, 10) {
				w.write_u32::<BE>(self.scene_frame_counter.as_ref().unwrap().value(i))?
			}
		};
		Ok(())
	}

	pub fn transpose_one(&self, i: usize, version: Version) -> columnar::Start {
		columnar::Start {
			random_seed: self.random_seed.as_ref().map(|x| x.values()[i]),
			scene_frame_counter: self.scene_frame_counter.as_ref().map(|x| x.values()[i]),
		}
	}
}

impl From<MutableStart> for Start {
	fn from(x: MutableStart) -> Self {
		Self {
			random_seed: x.random_seed.map(|x| x.into()),
			scene_frame_counter: x.scene_frame_counter.map(|x| x.into()),
		}
	}
}

pub struct End {
	pub latest_finalized_frame: Option<PrimitiveArray<i32>>,
}

impl End {
	fn data_type(version: Version) -> DataType {
		let mut fields = vec![];
		{
			if version.gte(3, 7) {
				fields.push(Field::new("latest_finalized_frame", DataType::Int32, false))
			}
		};
		DataType::Struct(fields)
	}

	fn into_struct_array(self, version: Version) -> StructArray {
		let mut values = vec![];
		{
			if version.gte(3, 7) {
				values.push(self.latest_finalized_frame.unwrap().boxed())
			}
		};
		StructArray::new(Self::data_type(version), values, None)
	}

	fn from_struct_array(array: StructArray, version: Version) -> Self {
		let (_, values, _) = array.into_data();
		Self {
			latest_finalized_frame: values.get(0).map(|x| {
				x.as_any()
					.downcast_ref::<PrimitiveArray<i32>>()
					.unwrap()
					.clone()
			}),
		}
	}

	fn write<W: Write>(&self, w: &mut W, version: Version, i: usize) -> Result<()> {
		if version.gte(3, 7) {
			w.write_i32::<BE>(self.latest_finalized_frame.as_ref().unwrap().value(i))?
		};
		Ok(())
	}

	pub fn transpose_one(&self, i: usize, version: Version) -> columnar::End {
		columnar::End {
			latest_finalized_frame: self.latest_finalized_frame.as_ref().map(|x| x.values()[i]),
		}
	}
}

impl From<MutableEnd> for End {
	fn from(x: MutableEnd) -> Self {
		Self {
			latest_finalized_frame: x.latest_finalized_frame.map(|x| x.into()),
		}
	}
}

pub struct StateFlags(
	pub PrimitiveArray<u8>,
	pub PrimitiveArray<u8>,
	pub PrimitiveArray<u8>,
	pub PrimitiveArray<u8>,
	pub PrimitiveArray<u8>,
);

impl StateFlags {
	fn data_type(version: Version) -> DataType {
		let mut fields = vec![];
		{
			fields.push(Field::new("0", DataType::UInt8, false));
			fields.push(Field::new("1", DataType::UInt8, false));
			fields.push(Field::new("2", DataType::UInt8, false));
			fields.push(Field::new("3", DataType::UInt8, false));
			fields.push(Field::new("4", DataType::UInt8, false))
		};
		DataType::Struct(fields)
	}

	fn into_struct_array(self, version: Version) -> StructArray {
		let mut values = vec![];
		{
			values.push(self.0.boxed());
			values.push(self.1.boxed());
			values.push(self.2.boxed());
			values.push(self.3.boxed());
			values.push(self.4.boxed())
		};
		StructArray::new(Self::data_type(version), values, None)
	}

	fn from_struct_array(array: StructArray, version: Version) -> Self {
		let (_, values, _) = array.into_data();
		Self(
			values[0]
				.as_any()
				.downcast_ref::<PrimitiveArray<u8>>()
				.unwrap()
				.clone(),
			values[1]
				.as_any()
				.downcast_ref::<PrimitiveArray<u8>>()
				.unwrap()
				.clone(),
			values[2]
				.as_any()
				.downcast_ref::<PrimitiveArray<u8>>()
				.unwrap()
				.clone(),
			values[3]
				.as_any()
				.downcast_ref::<PrimitiveArray<u8>>()
				.unwrap()
				.clone(),
			values[4]
				.as_any()
				.downcast_ref::<PrimitiveArray<u8>>()
				.unwrap()
				.clone(),
		)
	}

	fn write<W: Write>(&self, w: &mut W, version: Version, i: usize) -> Result<()> {
		w.write_u8(self.0.value(i))?;
		w.write_u8(self.1.value(i))?;
		w.write_u8(self.2.value(i))?;
		w.write_u8(self.3.value(i))?;
		w.write_u8(self.4.value(i))?;
		Ok(())
	}

	pub fn transpose_one(&self, i: usize, version: Version) -> columnar::StateFlags {
		columnar::StateFlags(
			self.0.values()[i],
			self.1.values()[i],
			self.2.values()[i],
			self.3.values()[i],
			self.4.values()[i],
		)
	}
}

impl From<MutableStateFlags> for StateFlags {
	fn from(x: MutableStateFlags) -> Self {
		Self(x.0.into(), x.1.into(), x.2.into(), x.3.into(), x.4.into())
	}
}

pub struct Pre {
	pub random_seed: PrimitiveArray<u32>,
	pub state: PrimitiveArray<u16>,
	pub position: Position,
	pub direction: PrimitiveArray<f32>,
	pub joystick: Position,
	pub cstick: Position,
	pub triggers: PrimitiveArray<f32>,
	pub buttons: PrimitiveArray<u32>,
	pub buttons_physical: PrimitiveArray<u16>,
	pub triggers_physical: TriggersPhysical,
	pub raw_analog_x: Option<PrimitiveArray<i8>>,
	pub percent: Option<PrimitiveArray<f32>>,
}

impl Pre {
	fn data_type(version: Version) -> DataType {
		let mut fields = vec![];
		{
			fields.push(Field::new("random_seed", DataType::UInt32, false));
			fields.push(Field::new("state", DataType::UInt16, false));
			fields.push(Field::new("position", Position::data_type(version), false));
			fields.push(Field::new("direction", DataType::Float32, false));
			fields.push(Field::new("joystick", Position::data_type(version), false));
			fields.push(Field::new("cstick", Position::data_type(version), false));
			fields.push(Field::new("triggers", DataType::Float32, false));
			fields.push(Field::new("buttons", DataType::UInt32, false));
			fields.push(Field::new("buttons_physical", DataType::UInt16, false));
			fields.push(Field::new(
				"triggers_physical",
				TriggersPhysical::data_type(version),
				false,
			));
			if version.gte(1, 2) {
				fields.push(Field::new("raw_analog_x", DataType::Int8, false));
				if version.gte(1, 4) {
					fields.push(Field::new("percent", DataType::Float32, false))
				}
			}
		};
		DataType::Struct(fields)
	}

	fn into_struct_array(self, version: Version) -> StructArray {
		let mut values = vec![];
		{
			values.push(self.random_seed.boxed());
			values.push(self.state.boxed());
			values.push(self.position.into_struct_array(version).boxed());
			values.push(self.direction.boxed());
			values.push(self.joystick.into_struct_array(version).boxed());
			values.push(self.cstick.into_struct_array(version).boxed());
			values.push(self.triggers.boxed());
			values.push(self.buttons.boxed());
			values.push(self.buttons_physical.boxed());
			values.push(self.triggers_physical.into_struct_array(version).boxed());
			if version.gte(1, 2) {
				values.push(self.raw_analog_x.unwrap().boxed());
				if version.gte(1, 4) {
					values.push(self.percent.unwrap().boxed())
				}
			}
		};
		StructArray::new(Self::data_type(version), values, None)
	}

	fn from_struct_array(array: StructArray, version: Version) -> Self {
		let (_, values, _) = array.into_data();
		Self {
			random_seed: values[0]
				.as_any()
				.downcast_ref::<PrimitiveArray<u32>>()
				.unwrap()
				.clone(),
			state: values[1]
				.as_any()
				.downcast_ref::<PrimitiveArray<u16>>()
				.unwrap()
				.clone(),
			position: Position::from_struct_array(
				values[2]
					.as_any()
					.downcast_ref::<StructArray>()
					.unwrap()
					.clone(),
				version,
			),
			direction: values[3]
				.as_any()
				.downcast_ref::<PrimitiveArray<f32>>()
				.unwrap()
				.clone(),
			joystick: Position::from_struct_array(
				values[4]
					.as_any()
					.downcast_ref::<StructArray>()
					.unwrap()
					.clone(),
				version,
			),
			cstick: Position::from_struct_array(
				values[5]
					.as_any()
					.downcast_ref::<StructArray>()
					.unwrap()
					.clone(),
				version,
			),
			triggers: values[6]
				.as_any()
				.downcast_ref::<PrimitiveArray<f32>>()
				.unwrap()
				.clone(),
			buttons: values[7]
				.as_any()
				.downcast_ref::<PrimitiveArray<u32>>()
				.unwrap()
				.clone(),
			buttons_physical: values[8]
				.as_any()
				.downcast_ref::<PrimitiveArray<u16>>()
				.unwrap()
				.clone(),
			triggers_physical: TriggersPhysical::from_struct_array(
				values[9]
					.as_any()
					.downcast_ref::<StructArray>()
					.unwrap()
					.clone(),
				version,
			),
			raw_analog_x: values.get(10).map(|x| {
				x.as_any()
					.downcast_ref::<PrimitiveArray<i8>>()
					.unwrap()
					.clone()
			}),
			percent: values.get(11).map(|x| {
				x.as_any()
					.downcast_ref::<PrimitiveArray<f32>>()
					.unwrap()
					.clone()
			}),
		}
	}

	fn write<W: Write>(&self, w: &mut W, version: Version, i: usize) -> Result<()> {
		w.write_u32::<BE>(self.random_seed.value(i))?;
		w.write_u16::<BE>(self.state.value(i))?;
		self.position.write(w, version, i)?;
		w.write_f32::<BE>(self.direction.value(i))?;
		self.joystick.write(w, version, i)?;
		self.cstick.write(w, version, i)?;
		w.write_f32::<BE>(self.triggers.value(i))?;
		w.write_u32::<BE>(self.buttons.value(i))?;
		w.write_u16::<BE>(self.buttons_physical.value(i))?;
		self.triggers_physical.write(w, version, i)?;
		if version.gte(1, 2) {
			w.write_i8(self.raw_analog_x.as_ref().unwrap().value(i))?;
			if version.gte(1, 4) {
				w.write_f32::<BE>(self.percent.as_ref().unwrap().value(i))?
			}
		};
		Ok(())
	}

	pub fn transpose_one(&self, i: usize, version: Version) -> columnar::Pre {
		columnar::Pre {
			random_seed: self.random_seed.values()[i],
			state: self.state.values()[i],
			position: self.position.transpose_one(i, version),
			direction: self.direction.values()[i],
			joystick: self.joystick.transpose_one(i, version),
			cstick: self.cstick.transpose_one(i, version),
			triggers: self.triggers.values()[i],
			buttons: self.buttons.values()[i],
			buttons_physical: self.buttons_physical.values()[i],
			triggers_physical: self.triggers_physical.transpose_one(i, version),
			raw_analog_x: self.raw_analog_x.as_ref().map(|x| x.values()[i]),
			percent: self.percent.as_ref().map(|x| x.values()[i]),
		}
	}
}

impl From<MutablePre> for Pre {
	fn from(x: MutablePre) -> Self {
		Self {
			random_seed: x.random_seed.into(),
			state: x.state.into(),
			position: x.position.into(),
			direction: x.direction.into(),
			joystick: x.joystick.into(),
			cstick: x.cstick.into(),
			triggers: x.triggers.into(),
			buttons: x.buttons.into(),
			buttons_physical: x.buttons_physical.into(),
			triggers_physical: x.triggers_physical.into(),
			raw_analog_x: x.raw_analog_x.map(|x| x.into()),
			percent: x.percent.map(|x| x.into()),
		}
	}
}

pub struct ItemMisc(
	pub PrimitiveArray<u8>,
	pub PrimitiveArray<u8>,
	pub PrimitiveArray<u8>,
	pub PrimitiveArray<u8>,
);

impl ItemMisc {
	fn data_type(version: Version) -> DataType {
		let mut fields = vec![];
		{
			fields.push(Field::new("0", DataType::UInt8, false));
			fields.push(Field::new("1", DataType::UInt8, false));
			fields.push(Field::new("2", DataType::UInt8, false));
			fields.push(Field::new("3", DataType::UInt8, false))
		};
		DataType::Struct(fields)
	}

	fn into_struct_array(self, version: Version) -> StructArray {
		let mut values = vec![];
		{
			values.push(self.0.boxed());
			values.push(self.1.boxed());
			values.push(self.2.boxed());
			values.push(self.3.boxed())
		};
		StructArray::new(Self::data_type(version), values, None)
	}

	fn from_struct_array(array: StructArray, version: Version) -> Self {
		let (_, values, _) = array.into_data();
		Self(
			values[0]
				.as_any()
				.downcast_ref::<PrimitiveArray<u8>>()
				.unwrap()
				.clone(),
			values[1]
				.as_any()
				.downcast_ref::<PrimitiveArray<u8>>()
				.unwrap()
				.clone(),
			values[2]
				.as_any()
				.downcast_ref::<PrimitiveArray<u8>>()
				.unwrap()
				.clone(),
			values[3]
				.as_any()
				.downcast_ref::<PrimitiveArray<u8>>()
				.unwrap()
				.clone(),
		)
	}

	fn write<W: Write>(&self, w: &mut W, version: Version, i: usize) -> Result<()> {
		w.write_u8(self.0.value(i))?;
		w.write_u8(self.1.value(i))?;
		w.write_u8(self.2.value(i))?;
		w.write_u8(self.3.value(i))?;
		Ok(())
	}

	pub fn transpose_one(&self, i: usize, version: Version) -> columnar::ItemMisc {
		columnar::ItemMisc(
			self.0.values()[i],
			self.1.values()[i],
			self.2.values()[i],
			self.3.values()[i],
		)
	}
}

impl From<MutableItemMisc> for ItemMisc {
	fn from(x: MutableItemMisc) -> Self {
		Self(x.0.into(), x.1.into(), x.2.into(), x.3.into())
	}
}

pub struct Position {
	pub x: PrimitiveArray<f32>,
	pub y: PrimitiveArray<f32>,
}

impl Position {
	fn data_type(version: Version) -> DataType {
		let mut fields = vec![];
		{
			fields.push(Field::new("x", DataType::Float32, false));
			fields.push(Field::new("y", DataType::Float32, false))
		};
		DataType::Struct(fields)
	}

	fn into_struct_array(self, version: Version) -> StructArray {
		let mut values = vec![];
		{
			values.push(self.x.boxed());
			values.push(self.y.boxed())
		};
		StructArray::new(Self::data_type(version), values, None)
	}

	fn from_struct_array(array: StructArray, version: Version) -> Self {
		let (_, values, _) = array.into_data();
		Self {
			x: values[0]
				.as_any()
				.downcast_ref::<PrimitiveArray<f32>>()
				.unwrap()
				.clone(),
			y: values[1]
				.as_any()
				.downcast_ref::<PrimitiveArray<f32>>()
				.unwrap()
				.clone(),
		}
	}

	fn write<W: Write>(&self, w: &mut W, version: Version, i: usize) -> Result<()> {
		w.write_f32::<BE>(self.x.value(i))?;
		w.write_f32::<BE>(self.y.value(i))?;
		Ok(())
	}

	pub fn transpose_one(&self, i: usize, version: Version) -> columnar::Position {
		columnar::Position {
			x: self.x.values()[i],
			y: self.y.values()[i],
		}
	}
}

impl From<MutablePosition> for Position {
	fn from(x: MutablePosition) -> Self {
		Self {
			x: x.x.into(),
			y: x.y.into(),
		}
	}
}

pub struct Velocities {
	pub self_x_air: PrimitiveArray<f32>,
	pub self_y: PrimitiveArray<f32>,
	pub knockback_x: PrimitiveArray<f32>,
	pub knockback_y: PrimitiveArray<f32>,
	pub self_x_ground: PrimitiveArray<f32>,
}

impl Velocities {
	fn data_type(version: Version) -> DataType {
		let mut fields = vec![];
		{
			fields.push(Field::new("self_x_air", DataType::Float32, false));
			fields.push(Field::new("self_y", DataType::Float32, false));
			fields.push(Field::new("knockback_x", DataType::Float32, false));
			fields.push(Field::new("knockback_y", DataType::Float32, false));
			fields.push(Field::new("self_x_ground", DataType::Float32, false))
		};
		DataType::Struct(fields)
	}

	fn into_struct_array(self, version: Version) -> StructArray {
		let mut values = vec![];
		{
			values.push(self.self_x_air.boxed());
			values.push(self.self_y.boxed());
			values.push(self.knockback_x.boxed());
			values.push(self.knockback_y.boxed());
			values.push(self.self_x_ground.boxed())
		};
		StructArray::new(Self::data_type(version), values, None)
	}

	fn from_struct_array(array: StructArray, version: Version) -> Self {
		let (_, values, _) = array.into_data();
		Self {
			self_x_air: values[0]
				.as_any()
				.downcast_ref::<PrimitiveArray<f32>>()
				.unwrap()
				.clone(),
			self_y: values[1]
				.as_any()
				.downcast_ref::<PrimitiveArray<f32>>()
				.unwrap()
				.clone(),
			knockback_x: values[2]
				.as_any()
				.downcast_ref::<PrimitiveArray<f32>>()
				.unwrap()
				.clone(),
			knockback_y: values[3]
				.as_any()
				.downcast_ref::<PrimitiveArray<f32>>()
				.unwrap()
				.clone(),
			self_x_ground: values[4]
				.as_any()
				.downcast_ref::<PrimitiveArray<f32>>()
				.unwrap()
				.clone(),
		}
	}

	fn write<W: Write>(&self, w: &mut W, version: Version, i: usize) -> Result<()> {
		w.write_f32::<BE>(self.self_x_air.value(i))?;
		w.write_f32::<BE>(self.self_y.value(i))?;
		w.write_f32::<BE>(self.knockback_x.value(i))?;
		w.write_f32::<BE>(self.knockback_y.value(i))?;
		w.write_f32::<BE>(self.self_x_ground.value(i))?;
		Ok(())
	}

	pub fn transpose_one(&self, i: usize, version: Version) -> columnar::Velocities {
		columnar::Velocities {
			self_x_air: self.self_x_air.values()[i],
			self_y: self.self_y.values()[i],
			knockback_x: self.knockback_x.values()[i],
			knockback_y: self.knockback_y.values()[i],
			self_x_ground: self.self_x_ground.values()[i],
		}
	}
}

impl From<MutableVelocities> for Velocities {
	fn from(x: MutableVelocities) -> Self {
		Self {
			self_x_air: x.self_x_air.into(),
			self_y: x.self_y.into(),
			knockback_x: x.knockback_x.into(),
			knockback_y: x.knockback_y.into(),
			self_x_ground: x.self_x_ground.into(),
		}
	}
}

pub struct TriggersPhysical {
	pub l: PrimitiveArray<f32>,
	pub r: PrimitiveArray<f32>,
}

impl TriggersPhysical {
	fn data_type(version: Version) -> DataType {
		let mut fields = vec![];
		{
			fields.push(Field::new("l", DataType::Float32, false));
			fields.push(Field::new("r", DataType::Float32, false))
		};
		DataType::Struct(fields)
	}

	fn into_struct_array(self, version: Version) -> StructArray {
		let mut values = vec![];
		{
			values.push(self.l.boxed());
			values.push(self.r.boxed())
		};
		StructArray::new(Self::data_type(version), values, None)
	}

	fn from_struct_array(array: StructArray, version: Version) -> Self {
		let (_, values, _) = array.into_data();
		Self {
			l: values[0]
				.as_any()
				.downcast_ref::<PrimitiveArray<f32>>()
				.unwrap()
				.clone(),
			r: values[1]
				.as_any()
				.downcast_ref::<PrimitiveArray<f32>>()
				.unwrap()
				.clone(),
		}
	}

	fn write<W: Write>(&self, w: &mut W, version: Version, i: usize) -> Result<()> {
		w.write_f32::<BE>(self.l.value(i))?;
		w.write_f32::<BE>(self.r.value(i))?;
		Ok(())
	}

	pub fn transpose_one(&self, i: usize, version: Version) -> columnar::TriggersPhysical {
		columnar::TriggersPhysical {
			l: self.l.values()[i],
			r: self.r.values()[i],
		}
	}
}

impl From<MutableTriggersPhysical> for TriggersPhysical {
	fn from(x: MutableTriggersPhysical) -> Self {
		Self {
			l: x.l.into(),
			r: x.r.into(),
		}
	}
}

pub struct Velocity {
	pub x: PrimitiveArray<f32>,
	pub y: PrimitiveArray<f32>,
}

impl Velocity {
	fn data_type(version: Version) -> DataType {
		let mut fields = vec![];
		{
			fields.push(Field::new("x", DataType::Float32, false));
			fields.push(Field::new("y", DataType::Float32, false))
		};
		DataType::Struct(fields)
	}

	fn into_struct_array(self, version: Version) -> StructArray {
		let mut values = vec![];
		{
			values.push(self.x.boxed());
			values.push(self.y.boxed())
		};
		StructArray::new(Self::data_type(version), values, None)
	}

	fn from_struct_array(array: StructArray, version: Version) -> Self {
		let (_, values, _) = array.into_data();
		Self {
			x: values[0]
				.as_any()
				.downcast_ref::<PrimitiveArray<f32>>()
				.unwrap()
				.clone(),
			y: values[1]
				.as_any()
				.downcast_ref::<PrimitiveArray<f32>>()
				.unwrap()
				.clone(),
		}
	}

	fn write<W: Write>(&self, w: &mut W, version: Version, i: usize) -> Result<()> {
		w.write_f32::<BE>(self.x.value(i))?;
		w.write_f32::<BE>(self.y.value(i))?;
		Ok(())
	}

	pub fn transpose_one(&self, i: usize, version: Version) -> columnar::Velocity {
		columnar::Velocity {
			x: self.x.values()[i],
			y: self.y.values()[i],
		}
	}
}

impl From<MutableVelocity> for Velocity {
	fn from(x: MutableVelocity) -> Self {
		Self {
			x: x.x.into(),
			y: x.y.into(),
		}
	}
}

pub struct Item {
	pub r#type: PrimitiveArray<u16>,
	pub state: PrimitiveArray<u8>,
	pub direction: PrimitiveArray<f32>,
	pub velocity: Velocity,
	pub position: Position,
	pub damage: PrimitiveArray<u16>,
	pub timer: PrimitiveArray<f32>,
	pub id: PrimitiveArray<u32>,
	pub misc: Option<ItemMisc>,
	pub owner: Option<PrimitiveArray<i8>>,
}

impl Item {
	fn data_type(version: Version) -> DataType {
		let mut fields = vec![];
		{
			fields.push(Field::new("type", DataType::UInt16, false));
			fields.push(Field::new("state", DataType::UInt8, false));
			fields.push(Field::new("direction", DataType::Float32, false));
			fields.push(Field::new("velocity", Velocity::data_type(version), false));
			fields.push(Field::new("position", Position::data_type(version), false));
			fields.push(Field::new("damage", DataType::UInt16, false));
			fields.push(Field::new("timer", DataType::Float32, false));
			fields.push(Field::new("id", DataType::UInt32, false));
			if version.gte(3, 2) {
				fields.push(Field::new("misc", ItemMisc::data_type(version), false));
				if version.gte(3, 6) {
					fields.push(Field::new("owner", DataType::Int8, false))
				}
			}
		};
		DataType::Struct(fields)
	}

	fn into_struct_array(self, version: Version) -> StructArray {
		let mut values = vec![];
		{
			values.push(self.r#type.boxed());
			values.push(self.state.boxed());
			values.push(self.direction.boxed());
			values.push(self.velocity.into_struct_array(version).boxed());
			values.push(self.position.into_struct_array(version).boxed());
			values.push(self.damage.boxed());
			values.push(self.timer.boxed());
			values.push(self.id.boxed());
			if version.gte(3, 2) {
				values.push(self.misc.unwrap().into_struct_array(version).boxed());
				if version.gte(3, 6) {
					values.push(self.owner.unwrap().boxed())
				}
			}
		};
		StructArray::new(Self::data_type(version), values, None)
	}

	fn from_struct_array(array: StructArray, version: Version) -> Self {
		let (_, values, _) = array.into_data();
		Self {
			r#type: values[0]
				.as_any()
				.downcast_ref::<PrimitiveArray<u16>>()
				.unwrap()
				.clone(),
			state: values[1]
				.as_any()
				.downcast_ref::<PrimitiveArray<u8>>()
				.unwrap()
				.clone(),
			direction: values[2]
				.as_any()
				.downcast_ref::<PrimitiveArray<f32>>()
				.unwrap()
				.clone(),
			velocity: Velocity::from_struct_array(
				values[3]
					.as_any()
					.downcast_ref::<StructArray>()
					.unwrap()
					.clone(),
				version,
			),
			position: Position::from_struct_array(
				values[4]
					.as_any()
					.downcast_ref::<StructArray>()
					.unwrap()
					.clone(),
				version,
			),
			damage: values[5]
				.as_any()
				.downcast_ref::<PrimitiveArray<u16>>()
				.unwrap()
				.clone(),
			timer: values[6]
				.as_any()
				.downcast_ref::<PrimitiveArray<f32>>()
				.unwrap()
				.clone(),
			id: values[7]
				.as_any()
				.downcast_ref::<PrimitiveArray<u32>>()
				.unwrap()
				.clone(),
			misc: values.get(8).map(|x| {
				ItemMisc::from_struct_array(
					x.as_any().downcast_ref::<StructArray>().unwrap().clone(),
					version,
				)
			}),
			owner: values.get(9).map(|x| {
				x.as_any()
					.downcast_ref::<PrimitiveArray<i8>>()
					.unwrap()
					.clone()
			}),
		}
	}

	fn write<W: Write>(&self, w: &mut W, version: Version, i: usize) -> Result<()> {
		w.write_u16::<BE>(self.r#type.value(i))?;
		w.write_u8(self.state.value(i))?;
		w.write_f32::<BE>(self.direction.value(i))?;
		self.velocity.write(w, version, i)?;
		self.position.write(w, version, i)?;
		w.write_u16::<BE>(self.damage.value(i))?;
		w.write_f32::<BE>(self.timer.value(i))?;
		w.write_u32::<BE>(self.id.value(i))?;
		if version.gte(3, 2) {
			self.misc.as_ref().unwrap().write(w, version, i)?;
			if version.gte(3, 6) {
				w.write_i8(self.owner.as_ref().unwrap().value(i))?
			}
		};
		Ok(())
	}

	pub fn transpose_one(&self, i: usize, version: Version) -> columnar::Item {
		columnar::Item {
			r#type: self.r#type.values()[i],
			state: self.state.values()[i],
			direction: self.direction.values()[i],
			velocity: self.velocity.transpose_one(i, version),
			position: self.position.transpose_one(i, version),
			damage: self.damage.values()[i],
			timer: self.timer.values()[i],
			id: self.id.values()[i],
			misc: self.misc.as_ref().map(|x| x.transpose_one(i, version)),
			owner: self.owner.as_ref().map(|x| x.values()[i]),
		}
	}
}

impl From<MutableItem> for Item {
	fn from(x: MutableItem) -> Self {
		Self {
			r#type: x.r#type.into(),
			state: x.state.into(),
			direction: x.direction.into(),
			velocity: x.velocity.into(),
			position: x.position.into(),
			damage: x.damage.into(),
			timer: x.timer.into(),
			id: x.id.into(),
			misc: x.misc.map(|x| x.into()),
			owner: x.owner.map(|x| x.into()),
		}
	}
}
