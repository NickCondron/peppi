// This file is auto-generated by `gen/scripts/regen`. Do not edit.

#![allow(unused_parens)]
#![allow(unused_variables)]
#![allow(dead_code)]

use arrow2::{
	array::{MutableArray, MutablePrimitiveArray},
	bitmap::MutableBitmap,
	offset::Offsets,
};

use byteorder::ReadBytesExt;
use std::io::Result;

use crate::{
	io::slippi::Version,
	model::{
		frame::{transpose, PortOccupancy},
		game::Port,
	},
};

type BE = byteorder::BigEndian;

pub struct Data {
	pub pre: Pre,
	pub post: Post,
	pub validity: Option<MutableBitmap>,
}

impl Data {
	pub fn with_capacity(capacity: usize, version: Version) -> Self {
		Self {
			pre: Pre::with_capacity(capacity, version),
			post: Post::with_capacity(capacity, version),
			validity: None,
		}
	}

	pub fn len(&self) -> usize {
		self.pre.len()
	}

	pub fn push_null(&mut self, version: Version) {
		let len = self.len();
		self.validity
			.get_or_insert_with(|| MutableBitmap::from_len_set(len))
			.push(false);
		self.pre.push_null(version);
		self.post.push_null(version);
	}

	pub fn transpose_one(&self, i: usize, version: Version) -> transpose::Data {
		transpose::Data {
			pre: self.pre.transpose_one(i, version),
			post: self.post.transpose_one(i, version),
		}
	}
}

pub struct PortData {
	pub port: Port,
	pub leader: Data,
	pub follower: Option<Data>,
}

impl PortData {
	pub fn with_capacity(capacity: usize, version: Version, port: PortOccupancy) -> Self {
		Self {
			port: port.port,
			leader: Data::with_capacity(capacity, version),
			follower: match port.follower {
				true => Some(Data::with_capacity(capacity, version)),
				_ => None,
			},
		}
	}

	pub fn len(&self) -> usize {
		self.leader.len()
	}

	pub fn transpose_one(&self, i: usize, version: Version) -> transpose::PortData {
		transpose::PortData {
			port: self.port,
			leader: self.leader.transpose_one(i, version),
			follower: self.follower.as_ref().map(|f| f.transpose_one(i, version)),
		}
	}
}

pub struct Frame {
	pub id: MutablePrimitiveArray<i32>,
	pub ports: Vec<PortData>,
	pub start: Option<Start>,
	pub end: Option<End>,
	pub item_offset: Option<Offsets<i32>>,
	pub item: Option<Item>,
}

impl Frame {
	pub fn with_capacity(capacity: usize, version: Version, ports: &[PortOccupancy]) -> Self {
		Self {
			id: MutablePrimitiveArray::<i32>::with_capacity(capacity),
			ports: ports
				.iter()
				.map(|p| PortData::with_capacity(capacity, version, *p))
				.collect(),
			start: version
				.gte(2, 2)
				.then(|| Start::with_capacity(capacity, version)),
			end: version
				.gte(3, 0)
				.then(|| End::with_capacity(capacity, version)),
			item_offset: version
				.gte(3, 0)
				.then(|| Offsets::<i32>::with_capacity(capacity)),
			item: version.gte(3, 0).then(|| Item::with_capacity(0, version)),
		}
	}

	pub fn len(&self) -> usize {
		self.id.len()
	}

	pub fn transpose_one(&self, i: usize, version: Version) -> transpose::Frame {
		transpose::Frame {
			id: self.id.values()[i],
			ports: self
				.ports
				.iter()
				.map(|p| p.transpose_one(i, version))
				.collect(),
			start: version
				.gte(2, 2)
				.then(|| self.start.as_ref().unwrap().transpose_one(i, version)),
			end: version
				.gte(3, 0)
				.then(|| self.end.as_ref().unwrap().transpose_one(i, version)),
			items: version.gte(3, 0).then(|| {
				let (start, end) = self.item_offset.as_ref().unwrap().start_end(i);
				(start..end)
					.map(|i| self.item.as_ref().unwrap().transpose_one(i, version))
					.collect()
			}),
		}
	}
}

pub struct End {
	pub latest_finalized_frame: Option<MutablePrimitiveArray<i32>>,
	pub validity: Option<MutableBitmap>,
}

impl End {
	fn with_capacity(capacity: usize, version: Version) -> Self {
		Self {
			latest_finalized_frame: version
				.gte(3, 7)
				.then(|| MutablePrimitiveArray::<i32>::with_capacity(capacity)),
			validity: version
				.lt(3, 7)
				.then(|| MutableBitmap::with_capacity(capacity)),
		}
	}

	pub fn len(&self) -> usize {
		self.validity
			.as_ref()
			.map(|v| v.len())
			.unwrap_or_else(|| self.latest_finalized_frame.as_ref().unwrap().len())
	}

	pub fn push_null(&mut self, version: Version) {
		let len = self.len();
		self.validity
			.get_or_insert_with(|| MutableBitmap::from_len_set(len))
			.push(false);
		if version.gte(3, 7) {
			self.latest_finalized_frame.as_mut().unwrap().push_null()
		}
	}

	pub fn read_push(&mut self, r: &mut &[u8], version: Version) -> Result<()> {
		if version.gte(3, 7) {
			r.read_i32::<BE>()
				.map(|x| self.latest_finalized_frame.as_mut().unwrap().push(Some(x)))?
		};
		self.validity.as_mut().map(|v| v.push(true));
		Ok(())
	}

	pub fn transpose_one(&self, i: usize, version: Version) -> transpose::End {
		transpose::End {
			latest_finalized_frame: self.latest_finalized_frame.as_ref().map(|x| x.values()[i]),
		}
	}
}

pub struct Item {
	pub r#type: MutablePrimitiveArray<u16>,
	pub state: MutablePrimitiveArray<u8>,
	pub direction: MutablePrimitiveArray<f32>,
	pub velocity: Velocity,
	pub position: Position,
	pub damage: MutablePrimitiveArray<u16>,
	pub timer: MutablePrimitiveArray<f32>,
	pub id: MutablePrimitiveArray<u32>,
	pub misc: Option<ItemMisc>,
	pub owner: Option<MutablePrimitiveArray<i8>>,
	pub validity: Option<MutableBitmap>,
}

impl Item {
	fn with_capacity(capacity: usize, version: Version) -> Self {
		Self {
			r#type: MutablePrimitiveArray::<u16>::with_capacity(capacity),
			state: MutablePrimitiveArray::<u8>::with_capacity(capacity),
			direction: MutablePrimitiveArray::<f32>::with_capacity(capacity),
			velocity: Velocity::with_capacity(capacity, version),
			position: Position::with_capacity(capacity, version),
			damage: MutablePrimitiveArray::<u16>::with_capacity(capacity),
			timer: MutablePrimitiveArray::<f32>::with_capacity(capacity),
			id: MutablePrimitiveArray::<u32>::with_capacity(capacity),
			misc: version
				.gte(3, 2)
				.then(|| ItemMisc::with_capacity(capacity, version)),
			owner: version
				.gte(3, 6)
				.then(|| MutablePrimitiveArray::<i8>::with_capacity(capacity)),
			validity: None,
		}
	}

	pub fn len(&self) -> usize {
		self.r#type.len()
	}

	pub fn push_null(&mut self, version: Version) {
		let len = self.len();
		self.validity
			.get_or_insert_with(|| MutableBitmap::from_len_set(len))
			.push(false);
		self.r#type.push_null();
		self.state.push_null();
		self.direction.push_null();
		self.velocity.push_null(version);
		self.position.push_null(version);
		self.damage.push_null();
		self.timer.push_null();
		self.id.push_null();
		if version.gte(3, 2) {
			self.misc.as_mut().unwrap().push_null(version);
			if version.gte(3, 6) {
				self.owner.as_mut().unwrap().push_null()
			}
		}
	}

	pub fn read_push(&mut self, r: &mut &[u8], version: Version) -> Result<()> {
		r.read_u16::<BE>().map(|x| self.r#type.push(Some(x)))?;
		r.read_u8().map(|x| self.state.push(Some(x)))?;
		r.read_f32::<BE>().map(|x| self.direction.push(Some(x)))?;
		self.velocity.read_push(r, version)?;
		self.position.read_push(r, version)?;
		r.read_u16::<BE>().map(|x| self.damage.push(Some(x)))?;
		r.read_f32::<BE>().map(|x| self.timer.push(Some(x)))?;
		r.read_u32::<BE>().map(|x| self.id.push(Some(x)))?;
		if version.gte(3, 2) {
			self.misc.as_mut().unwrap().read_push(r, version)?;
			if version.gte(3, 6) {
				r.read_i8()
					.map(|x| self.owner.as_mut().unwrap().push(Some(x)))?
			}
		};
		self.validity.as_mut().map(|v| v.push(true));
		Ok(())
	}

	pub fn transpose_one(&self, i: usize, version: Version) -> transpose::Item {
		transpose::Item {
			r#type: self.r#type.values()[i],
			state: self.state.values()[i],
			direction: self.direction.values()[i],
			velocity: self.velocity.transpose_one(i, version),
			position: self.position.transpose_one(i, version),
			damage: self.damage.values()[i],
			timer: self.timer.values()[i],
			id: self.id.values()[i],
			misc: self.misc.as_ref().map(|x| x.transpose_one(i, version)),
			owner: self.owner.as_ref().map(|x| x.values()[i]),
		}
	}
}

pub struct ItemMisc(
	pub MutablePrimitiveArray<u8>,
	pub MutablePrimitiveArray<u8>,
	pub MutablePrimitiveArray<u8>,
	pub MutablePrimitiveArray<u8>,
);

impl ItemMisc {
	fn with_capacity(capacity: usize, version: Version) -> Self {
		Self(
			MutablePrimitiveArray::<u8>::with_capacity(capacity),
			MutablePrimitiveArray::<u8>::with_capacity(capacity),
			MutablePrimitiveArray::<u8>::with_capacity(capacity),
			MutablePrimitiveArray::<u8>::with_capacity(capacity),
		)
	}

	pub fn len(&self) -> usize {
		self.0.len()
	}

	pub fn push_null(&mut self, version: Version) {
		self.0.push_null();
		self.1.push_null();
		self.2.push_null();
		self.3.push_null()
	}

	pub fn read_push(&mut self, r: &mut &[u8], version: Version) -> Result<()> {
		r.read_u8().map(|x| self.0.push(Some(x)))?;
		r.read_u8().map(|x| self.1.push(Some(x)))?;
		r.read_u8().map(|x| self.2.push(Some(x)))?;
		r.read_u8().map(|x| self.3.push(Some(x)))?;
		Ok(())
	}

	pub fn transpose_one(&self, i: usize, version: Version) -> transpose::ItemMisc {
		transpose::ItemMisc(
			self.0.values()[i],
			self.1.values()[i],
			self.2.values()[i],
			self.3.values()[i],
		)
	}
}

pub struct Position {
	pub x: MutablePrimitiveArray<f32>,
	pub y: MutablePrimitiveArray<f32>,
	pub validity: Option<MutableBitmap>,
}

impl Position {
	fn with_capacity(capacity: usize, version: Version) -> Self {
		Self {
			x: MutablePrimitiveArray::<f32>::with_capacity(capacity),
			y: MutablePrimitiveArray::<f32>::with_capacity(capacity),
			validity: None,
		}
	}

	pub fn len(&self) -> usize {
		self.x.len()
	}

	pub fn push_null(&mut self, version: Version) {
		let len = self.len();
		self.validity
			.get_or_insert_with(|| MutableBitmap::from_len_set(len))
			.push(false);
		self.x.push_null();
		self.y.push_null()
	}

	pub fn read_push(&mut self, r: &mut &[u8], version: Version) -> Result<()> {
		r.read_f32::<BE>().map(|x| self.x.push(Some(x)))?;
		r.read_f32::<BE>().map(|x| self.y.push(Some(x)))?;
		self.validity.as_mut().map(|v| v.push(true));
		Ok(())
	}

	pub fn transpose_one(&self, i: usize, version: Version) -> transpose::Position {
		transpose::Position {
			x: self.x.values()[i],
			y: self.y.values()[i],
		}
	}
}

pub struct Post {
	pub character: MutablePrimitiveArray<u8>,
	pub state: MutablePrimitiveArray<u16>,
	pub position: Position,
	pub direction: MutablePrimitiveArray<f32>,
	pub percent: MutablePrimitiveArray<f32>,
	pub shield: MutablePrimitiveArray<f32>,
	pub last_attack_landed: MutablePrimitiveArray<u8>,
	pub combo_count: MutablePrimitiveArray<u8>,
	pub last_hit_by: MutablePrimitiveArray<u8>,
	pub stocks: MutablePrimitiveArray<u8>,
	pub state_age: Option<MutablePrimitiveArray<f32>>,
	pub state_flags: Option<StateFlags>,
	pub misc_as: Option<MutablePrimitiveArray<f32>>,
	pub airborne: Option<MutablePrimitiveArray<u8>>,
	pub ground: Option<MutablePrimitiveArray<u16>>,
	pub jumps: Option<MutablePrimitiveArray<u8>>,
	pub l_cancel: Option<MutablePrimitiveArray<u8>>,
	pub hurtbox_state: Option<MutablePrimitiveArray<u8>>,
	pub velocities: Option<Velocities>,
	pub hitlag: Option<MutablePrimitiveArray<f32>>,
	pub animation_index: Option<MutablePrimitiveArray<u32>>,
	pub validity: Option<MutableBitmap>,
}

impl Post {
	fn with_capacity(capacity: usize, version: Version) -> Self {
		Self {
			character: MutablePrimitiveArray::<u8>::with_capacity(capacity),
			state: MutablePrimitiveArray::<u16>::with_capacity(capacity),
			position: Position::with_capacity(capacity, version),
			direction: MutablePrimitiveArray::<f32>::with_capacity(capacity),
			percent: MutablePrimitiveArray::<f32>::with_capacity(capacity),
			shield: MutablePrimitiveArray::<f32>::with_capacity(capacity),
			last_attack_landed: MutablePrimitiveArray::<u8>::with_capacity(capacity),
			combo_count: MutablePrimitiveArray::<u8>::with_capacity(capacity),
			last_hit_by: MutablePrimitiveArray::<u8>::with_capacity(capacity),
			stocks: MutablePrimitiveArray::<u8>::with_capacity(capacity),
			state_age: version
				.gte(0, 2)
				.then(|| MutablePrimitiveArray::<f32>::with_capacity(capacity)),
			state_flags: version
				.gte(2, 0)
				.then(|| StateFlags::with_capacity(capacity, version)),
			misc_as: version
				.gte(2, 0)
				.then(|| MutablePrimitiveArray::<f32>::with_capacity(capacity)),
			airborne: version
				.gte(2, 0)
				.then(|| MutablePrimitiveArray::<u8>::with_capacity(capacity)),
			ground: version
				.gte(2, 0)
				.then(|| MutablePrimitiveArray::<u16>::with_capacity(capacity)),
			jumps: version
				.gte(2, 0)
				.then(|| MutablePrimitiveArray::<u8>::with_capacity(capacity)),
			l_cancel: version
				.gte(2, 0)
				.then(|| MutablePrimitiveArray::<u8>::with_capacity(capacity)),
			hurtbox_state: version
				.gte(2, 1)
				.then(|| MutablePrimitiveArray::<u8>::with_capacity(capacity)),
			velocities: version
				.gte(3, 5)
				.then(|| Velocities::with_capacity(capacity, version)),
			hitlag: version
				.gte(3, 8)
				.then(|| MutablePrimitiveArray::<f32>::with_capacity(capacity)),
			animation_index: version
				.gte(3, 11)
				.then(|| MutablePrimitiveArray::<u32>::with_capacity(capacity)),
			validity: None,
		}
	}

	pub fn len(&self) -> usize {
		self.character.len()
	}

	pub fn push_null(&mut self, version: Version) {
		let len = self.len();
		self.validity
			.get_or_insert_with(|| MutableBitmap::from_len_set(len))
			.push(false);
		self.character.push_null();
		self.state.push_null();
		self.position.push_null(version);
		self.direction.push_null();
		self.percent.push_null();
		self.shield.push_null();
		self.last_attack_landed.push_null();
		self.combo_count.push_null();
		self.last_hit_by.push_null();
		self.stocks.push_null();
		if version.gte(0, 2) {
			self.state_age.as_mut().unwrap().push_null();
			if version.gte(2, 0) {
				self.state_flags.as_mut().unwrap().push_null(version);
				self.misc_as.as_mut().unwrap().push_null();
				self.airborne.as_mut().unwrap().push_null();
				self.ground.as_mut().unwrap().push_null();
				self.jumps.as_mut().unwrap().push_null();
				self.l_cancel.as_mut().unwrap().push_null();
				if version.gte(2, 1) {
					self.hurtbox_state.as_mut().unwrap().push_null();
					if version.gte(3, 5) {
						self.velocities.as_mut().unwrap().push_null(version);
						if version.gte(3, 8) {
							self.hitlag.as_mut().unwrap().push_null();
							if version.gte(3, 11) {
								self.animation_index.as_mut().unwrap().push_null()
							}
						}
					}
				}
			}
		}
	}

	pub fn read_push(&mut self, r: &mut &[u8], version: Version) -> Result<()> {
		r.read_u8().map(|x| self.character.push(Some(x)))?;
		r.read_u16::<BE>().map(|x| self.state.push(Some(x)))?;
		self.position.read_push(r, version)?;
		r.read_f32::<BE>().map(|x| self.direction.push(Some(x)))?;
		r.read_f32::<BE>().map(|x| self.percent.push(Some(x)))?;
		r.read_f32::<BE>().map(|x| self.shield.push(Some(x)))?;
		r.read_u8().map(|x| self.last_attack_landed.push(Some(x)))?;
		r.read_u8().map(|x| self.combo_count.push(Some(x)))?;
		r.read_u8().map(|x| self.last_hit_by.push(Some(x)))?;
		r.read_u8().map(|x| self.stocks.push(Some(x)))?;
		if version.gte(0, 2) {
			r.read_f32::<BE>()
				.map(|x| self.state_age.as_mut().unwrap().push(Some(x)))?;
			if version.gte(2, 0) {
				self.state_flags.as_mut().unwrap().read_push(r, version)?;
				r.read_f32::<BE>()
					.map(|x| self.misc_as.as_mut().unwrap().push(Some(x)))?;
				r.read_u8()
					.map(|x| self.airborne.as_mut().unwrap().push(Some(x)))?;
				r.read_u16::<BE>()
					.map(|x| self.ground.as_mut().unwrap().push(Some(x)))?;
				r.read_u8()
					.map(|x| self.jumps.as_mut().unwrap().push(Some(x)))?;
				r.read_u8()
					.map(|x| self.l_cancel.as_mut().unwrap().push(Some(x)))?;
				if version.gte(2, 1) {
					r.read_u8()
						.map(|x| self.hurtbox_state.as_mut().unwrap().push(Some(x)))?;
					if version.gte(3, 5) {
						self.velocities.as_mut().unwrap().read_push(r, version)?;
						if version.gte(3, 8) {
							r.read_f32::<BE>()
								.map(|x| self.hitlag.as_mut().unwrap().push(Some(x)))?;
							if version.gte(3, 11) {
								r.read_u32::<BE>()
									.map(|x| self.animation_index.as_mut().unwrap().push(Some(x)))?
							}
						}
					}
				}
			}
		};
		self.validity.as_mut().map(|v| v.push(true));
		Ok(())
	}

	pub fn transpose_one(&self, i: usize, version: Version) -> transpose::Post {
		transpose::Post {
			character: self.character.values()[i],
			state: self.state.values()[i],
			position: self.position.transpose_one(i, version),
			direction: self.direction.values()[i],
			percent: self.percent.values()[i],
			shield: self.shield.values()[i],
			last_attack_landed: self.last_attack_landed.values()[i],
			combo_count: self.combo_count.values()[i],
			last_hit_by: self.last_hit_by.values()[i],
			stocks: self.stocks.values()[i],
			state_age: self.state_age.as_ref().map(|x| x.values()[i]),
			state_flags: self
				.state_flags
				.as_ref()
				.map(|x| x.transpose_one(i, version)),
			misc_as: self.misc_as.as_ref().map(|x| x.values()[i]),
			airborne: self.airborne.as_ref().map(|x| x.values()[i]),
			ground: self.ground.as_ref().map(|x| x.values()[i]),
			jumps: self.jumps.as_ref().map(|x| x.values()[i]),
			l_cancel: self.l_cancel.as_ref().map(|x| x.values()[i]),
			hurtbox_state: self.hurtbox_state.as_ref().map(|x| x.values()[i]),
			velocities: self
				.velocities
				.as_ref()
				.map(|x| x.transpose_one(i, version)),
			hitlag: self.hitlag.as_ref().map(|x| x.values()[i]),
			animation_index: self.animation_index.as_ref().map(|x| x.values()[i]),
		}
	}
}

pub struct Pre {
	pub random_seed: MutablePrimitiveArray<u32>,
	pub state: MutablePrimitiveArray<u16>,
	pub position: Position,
	pub direction: MutablePrimitiveArray<f32>,
	pub joystick: Position,
	pub cstick: Position,
	pub triggers: MutablePrimitiveArray<f32>,
	pub buttons: MutablePrimitiveArray<u32>,
	pub buttons_physical: MutablePrimitiveArray<u16>,
	pub triggers_physical: TriggersPhysical,
	pub raw_analog_x: Option<MutablePrimitiveArray<i8>>,
	pub percent: Option<MutablePrimitiveArray<f32>>,
	pub raw_analog_y: Option<MutablePrimitiveArray<i8>>,
	pub validity: Option<MutableBitmap>,
}

impl Pre {
	fn with_capacity(capacity: usize, version: Version) -> Self {
		Self {
			random_seed: MutablePrimitiveArray::<u32>::with_capacity(capacity),
			state: MutablePrimitiveArray::<u16>::with_capacity(capacity),
			position: Position::with_capacity(capacity, version),
			direction: MutablePrimitiveArray::<f32>::with_capacity(capacity),
			joystick: Position::with_capacity(capacity, version),
			cstick: Position::with_capacity(capacity, version),
			triggers: MutablePrimitiveArray::<f32>::with_capacity(capacity),
			buttons: MutablePrimitiveArray::<u32>::with_capacity(capacity),
			buttons_physical: MutablePrimitiveArray::<u16>::with_capacity(capacity),
			triggers_physical: TriggersPhysical::with_capacity(capacity, version),
			raw_analog_x: version
				.gte(1, 2)
				.then(|| MutablePrimitiveArray::<i8>::with_capacity(capacity)),
			percent: version
				.gte(1, 4)
				.then(|| MutablePrimitiveArray::<f32>::with_capacity(capacity)),
			raw_analog_y: version
				.gte(3, 15)
				.then(|| MutablePrimitiveArray::<i8>::with_capacity(capacity)),
			validity: None,
		}
	}

	pub fn len(&self) -> usize {
		self.random_seed.len()
	}

	pub fn push_null(&mut self, version: Version) {
		let len = self.len();
		self.validity
			.get_or_insert_with(|| MutableBitmap::from_len_set(len))
			.push(false);
		self.random_seed.push_null();
		self.state.push_null();
		self.position.push_null(version);
		self.direction.push_null();
		self.joystick.push_null(version);
		self.cstick.push_null(version);
		self.triggers.push_null();
		self.buttons.push_null();
		self.buttons_physical.push_null();
		self.triggers_physical.push_null(version);
		if version.gte(1, 2) {
			self.raw_analog_x.as_mut().unwrap().push_null();
			if version.gte(1, 4) {
				self.percent.as_mut().unwrap().push_null();
				if version.gte(3, 15) {
					self.raw_analog_y.as_mut().unwrap().push_null()
				}
			}
		}
	}

	pub fn read_push(&mut self, r: &mut &[u8], version: Version) -> Result<()> {
		r.read_u32::<BE>().map(|x| self.random_seed.push(Some(x)))?;
		r.read_u16::<BE>().map(|x| self.state.push(Some(x)))?;
		self.position.read_push(r, version)?;
		r.read_f32::<BE>().map(|x| self.direction.push(Some(x)))?;
		self.joystick.read_push(r, version)?;
		self.cstick.read_push(r, version)?;
		r.read_f32::<BE>().map(|x| self.triggers.push(Some(x)))?;
		r.read_u32::<BE>().map(|x| self.buttons.push(Some(x)))?;
		r.read_u16::<BE>()
			.map(|x| self.buttons_physical.push(Some(x)))?;
		self.triggers_physical.read_push(r, version)?;
		if version.gte(1, 2) {
			r.read_i8()
				.map(|x| self.raw_analog_x.as_mut().unwrap().push(Some(x)))?;
			if version.gte(1, 4) {
				r.read_f32::<BE>()
					.map(|x| self.percent.as_mut().unwrap().push(Some(x)))?;
				if version.gte(3, 15) {
					r.read_i8()
						.map(|x| self.raw_analog_y.as_mut().unwrap().push(Some(x)))?
				}
			}
		};
		self.validity.as_mut().map(|v| v.push(true));
		Ok(())
	}

	pub fn transpose_one(&self, i: usize, version: Version) -> transpose::Pre {
		transpose::Pre {
			random_seed: self.random_seed.values()[i],
			state: self.state.values()[i],
			position: self.position.transpose_one(i, version),
			direction: self.direction.values()[i],
			joystick: self.joystick.transpose_one(i, version),
			cstick: self.cstick.transpose_one(i, version),
			triggers: self.triggers.values()[i],
			buttons: self.buttons.values()[i],
			buttons_physical: self.buttons_physical.values()[i],
			triggers_physical: self.triggers_physical.transpose_one(i, version),
			raw_analog_x: self.raw_analog_x.as_ref().map(|x| x.values()[i]),
			percent: self.percent.as_ref().map(|x| x.values()[i]),
			raw_analog_y: self.raw_analog_y.as_ref().map(|x| x.values()[i]),
		}
	}
}

pub struct Start {
	pub random_seed: MutablePrimitiveArray<u32>,
	pub scene_frame_counter: Option<MutablePrimitiveArray<u32>>,
	pub validity: Option<MutableBitmap>,
}

impl Start {
	fn with_capacity(capacity: usize, version: Version) -> Self {
		Self {
			random_seed: MutablePrimitiveArray::<u32>::with_capacity(capacity),
			scene_frame_counter: version
				.gte(3, 10)
				.then(|| MutablePrimitiveArray::<u32>::with_capacity(capacity)),
			validity: None,
		}
	}

	pub fn len(&self) -> usize {
		self.random_seed.len()
	}

	pub fn push_null(&mut self, version: Version) {
		let len = self.len();
		self.validity
			.get_or_insert_with(|| MutableBitmap::from_len_set(len))
			.push(false);
		self.random_seed.push_null();
		if version.gte(3, 10) {
			self.scene_frame_counter.as_mut().unwrap().push_null()
		}
	}

	pub fn read_push(&mut self, r: &mut &[u8], version: Version) -> Result<()> {
		r.read_u32::<BE>().map(|x| self.random_seed.push(Some(x)))?;
		if version.gte(3, 10) {
			r.read_u32::<BE>()
				.map(|x| self.scene_frame_counter.as_mut().unwrap().push(Some(x)))?
		};
		self.validity.as_mut().map(|v| v.push(true));
		Ok(())
	}

	pub fn transpose_one(&self, i: usize, version: Version) -> transpose::Start {
		transpose::Start {
			random_seed: self.random_seed.values()[i],
			scene_frame_counter: self.scene_frame_counter.as_ref().map(|x| x.values()[i]),
		}
	}
}

pub struct StateFlags(
	pub MutablePrimitiveArray<u8>,
	pub MutablePrimitiveArray<u8>,
	pub MutablePrimitiveArray<u8>,
	pub MutablePrimitiveArray<u8>,
	pub MutablePrimitiveArray<u8>,
);

impl StateFlags {
	fn with_capacity(capacity: usize, version: Version) -> Self {
		Self(
			MutablePrimitiveArray::<u8>::with_capacity(capacity),
			MutablePrimitiveArray::<u8>::with_capacity(capacity),
			MutablePrimitiveArray::<u8>::with_capacity(capacity),
			MutablePrimitiveArray::<u8>::with_capacity(capacity),
			MutablePrimitiveArray::<u8>::with_capacity(capacity),
		)
	}

	pub fn len(&self) -> usize {
		self.0.len()
	}

	pub fn push_null(&mut self, version: Version) {
		self.0.push_null();
		self.1.push_null();
		self.2.push_null();
		self.3.push_null();
		self.4.push_null()
	}

	pub fn read_push(&mut self, r: &mut &[u8], version: Version) -> Result<()> {
		r.read_u8().map(|x| self.0.push(Some(x)))?;
		r.read_u8().map(|x| self.1.push(Some(x)))?;
		r.read_u8().map(|x| self.2.push(Some(x)))?;
		r.read_u8().map(|x| self.3.push(Some(x)))?;
		r.read_u8().map(|x| self.4.push(Some(x)))?;
		Ok(())
	}

	pub fn transpose_one(&self, i: usize, version: Version) -> transpose::StateFlags {
		transpose::StateFlags(
			self.0.values()[i],
			self.1.values()[i],
			self.2.values()[i],
			self.3.values()[i],
			self.4.values()[i],
		)
	}
}

pub struct TriggersPhysical {
	pub l: MutablePrimitiveArray<f32>,
	pub r: MutablePrimitiveArray<f32>,
	pub validity: Option<MutableBitmap>,
}

impl TriggersPhysical {
	fn with_capacity(capacity: usize, version: Version) -> Self {
		Self {
			l: MutablePrimitiveArray::<f32>::with_capacity(capacity),
			r: MutablePrimitiveArray::<f32>::with_capacity(capacity),
			validity: None,
		}
	}

	pub fn len(&self) -> usize {
		self.l.len()
	}

	pub fn push_null(&mut self, version: Version) {
		let len = self.len();
		self.validity
			.get_or_insert_with(|| MutableBitmap::from_len_set(len))
			.push(false);
		self.l.push_null();
		self.r.push_null()
	}

	pub fn read_push(&mut self, r: &mut &[u8], version: Version) -> Result<()> {
		r.read_f32::<BE>().map(|x| self.l.push(Some(x)))?;
		r.read_f32::<BE>().map(|x| self.r.push(Some(x)))?;
		self.validity.as_mut().map(|v| v.push(true));
		Ok(())
	}

	pub fn transpose_one(&self, i: usize, version: Version) -> transpose::TriggersPhysical {
		transpose::TriggersPhysical {
			l: self.l.values()[i],
			r: self.r.values()[i],
		}
	}
}

pub struct Velocities {
	pub self_x_air: MutablePrimitiveArray<f32>,
	pub self_y: MutablePrimitiveArray<f32>,
	pub knockback_x: MutablePrimitiveArray<f32>,
	pub knockback_y: MutablePrimitiveArray<f32>,
	pub self_x_ground: MutablePrimitiveArray<f32>,
	pub validity: Option<MutableBitmap>,
}

impl Velocities {
	fn with_capacity(capacity: usize, version: Version) -> Self {
		Self {
			self_x_air: MutablePrimitiveArray::<f32>::with_capacity(capacity),
			self_y: MutablePrimitiveArray::<f32>::with_capacity(capacity),
			knockback_x: MutablePrimitiveArray::<f32>::with_capacity(capacity),
			knockback_y: MutablePrimitiveArray::<f32>::with_capacity(capacity),
			self_x_ground: MutablePrimitiveArray::<f32>::with_capacity(capacity),
			validity: None,
		}
	}

	pub fn len(&self) -> usize {
		self.self_x_air.len()
	}

	pub fn push_null(&mut self, version: Version) {
		let len = self.len();
		self.validity
			.get_or_insert_with(|| MutableBitmap::from_len_set(len))
			.push(false);
		self.self_x_air.push_null();
		self.self_y.push_null();
		self.knockback_x.push_null();
		self.knockback_y.push_null();
		self.self_x_ground.push_null()
	}

	pub fn read_push(&mut self, r: &mut &[u8], version: Version) -> Result<()> {
		r.read_f32::<BE>().map(|x| self.self_x_air.push(Some(x)))?;
		r.read_f32::<BE>().map(|x| self.self_y.push(Some(x)))?;
		r.read_f32::<BE>().map(|x| self.knockback_x.push(Some(x)))?;
		r.read_f32::<BE>().map(|x| self.knockback_y.push(Some(x)))?;
		r.read_f32::<BE>()
			.map(|x| self.self_x_ground.push(Some(x)))?;
		self.validity.as_mut().map(|v| v.push(true));
		Ok(())
	}

	pub fn transpose_one(&self, i: usize, version: Version) -> transpose::Velocities {
		transpose::Velocities {
			self_x_air: self.self_x_air.values()[i],
			self_y: self.self_y.values()[i],
			knockback_x: self.knockback_x.values()[i],
			knockback_y: self.knockback_y.values()[i],
			self_x_ground: self.self_x_ground.values()[i],
		}
	}
}

pub struct Velocity {
	pub x: MutablePrimitiveArray<f32>,
	pub y: MutablePrimitiveArray<f32>,
	pub validity: Option<MutableBitmap>,
}

impl Velocity {
	fn with_capacity(capacity: usize, version: Version) -> Self {
		Self {
			x: MutablePrimitiveArray::<f32>::with_capacity(capacity),
			y: MutablePrimitiveArray::<f32>::with_capacity(capacity),
			validity: None,
		}
	}

	pub fn len(&self) -> usize {
		self.x.len()
	}

	pub fn push_null(&mut self, version: Version) {
		let len = self.len();
		self.validity
			.get_or_insert_with(|| MutableBitmap::from_len_set(len))
			.push(false);
		self.x.push_null();
		self.y.push_null()
	}

	pub fn read_push(&mut self, r: &mut &[u8], version: Version) -> Result<()> {
		r.read_f32::<BE>().map(|x| self.x.push(Some(x)))?;
		r.read_f32::<BE>().map(|x| self.y.push(Some(x)))?;
		self.validity.as_mut().map(|v| v.push(true));
		Ok(())
	}

	pub fn transpose_one(&self, i: usize, version: Version) -> transpose::Velocity {
		transpose::Velocity {
			x: self.x.values()[i],
			y: self.y.values()[i],
		}
	}
}
